    "NumPy: The Foundation of Scientific Computing in Python\n",
    "\n",
    "#Introduction\n",
    "\n",
    "NumPy (Numerical Python) is the fundamental package for scientific computing in Python. It provides:\n",
    "\n",
    "- A powerful N-dimensional array object\n",
    "- Sophisticated broadcasting functions\n",
    "- Tools for integrating C/C++ and Fortran code\n",
    "- Useful linear algebra, Fourier transform, and random number capabilities\n",
    "\n",
    "This section will introduce you to the most essential NumPy concepts and functions that are widely used in machine learning and data science projects.\n",
    "\n",
    "**Source:** [NumPy Documentation](https://numpy.org/doc/stable/) and [numpy-ml](https://github.com/ddbourgin/numpy-ml)\n",
    "\n",
    "#Why NumPy?\n",
    "\n",
    "You can do numerical calculations using pure Python. In the beginning, you might think Python is fast enough, but once your data gets large, you'll start to notice slow downs.\n",
    "\n",
    "One of the main reasons to use NumPy is because it's fast. Behind the scenes, the code has been optimized to run using C. Which is another programming language that can do things much faster than Python.\n",
    "\n",
    "The benefit of this being behind the scenes is you don't need to know any C to take advantage of it. You can write your numerical computations in Python using NumPy and get the added speed benefits.\n",
    "\n",
    "**Source:** [Zero to Mastery ML](https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/section-2-data-science-and-ml-tools/introduction-to-numpy.ipynb)\n",
    "\n",
    "#1. NumPy Arrays: The Building Blocks\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "475f7174",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import NumPy\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "# ### 1.1 Creating NumPy Arrays\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e9c83e1d",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# From Python lists\n",
    "array_1d = np.array([1, 2, 3, 4, 5])\n",
    "array_2d = np.array([[1, 2, 3], [4, 5, 6]])\n",
    "\n",
    "print(\"1D Array:\")\n",
    "print(array_1d)\n",
    "print(\"\\n2D Array:\")\n",
    "print(array_2d)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d7eda934",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Creating arrays with specific values\n",
    "zeros = np.zeros((3, 4))  # 3x4 array of zeros\n",
    "ones = np.ones((2, 3))    # 2x3 array of ones\n",
    "full = np.full((2, 2), 7)  # 2x2 array filled with 7\n",
    "eye = np.eye(3)           # 3x3 identity matrix\n",
    "empty = np.empty((2, 3))  # 2x3 array with uninitialized values\n",
    "\n",
    "print(\"Zeros array:\")\n",
    "print(zeros)\n",
    "print(\"\\nOnes array:\")\n",
    "print(ones)\n",
    "print(\"\\nFull array (filled with 7):\")\n",
    "print(full)\n",
    "print(\"\\nIdentity matrix:\")\n",
    "print(eye)\n",
    "print(\"\\nEmpty array (uninitialized values):\")\n",
    "print(empty)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e2e72e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Creating arrays with sequences\n",
    "arange = np.arange(10)            # Values from 0 to 9\n",
    "arange_step = np.arange(1, 10, 2) # Values from 1 to 9 with step 2\n",
    "linspace = np.linspace(0, 1, 5)   # 5 evenly spaced values from 0 to 1\n",
    "\n",
    "print(\"np.arange(10):\")\n",
    "print(arange)\n",
    "print(\"\\nnp.arange(1, 10, 2):\")\n",
    "print(arange_step)\n",
    "print(\"\\nnp.linspace(0, 1, 5):\")\n",
    "print(linspace)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "76c14951",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Creating random arrays\n",
    "random_uniform = np.random.random((2, 3))     # Random values between 0 and 1\n",
    "random_normal = np.random.normal(0, 1, (2, 3)) # Normal distribution (mean=0, std=1)\n",
    "random_int = np.random.randint(0, 10, (3, 3))  # Random integers between 0 and 9\n",
    "\n",
    "print(\"Random uniform:\")\n",
    "print(random_uniform)\n",
    "print(\"\\nRandom normal:\")\n",
    "print(random_normal)\n",
    "print(\"\\nRandom integers:\")\n",
    "print(random_int)\n",
    "\n",
    "\n",
    "# ### 1.2 Array Attributes and Information\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45b0be54",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create a sample array\n",
    "sample_array = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n",
    "\n",
    "# Shape, dimensions, size, and data type\n",
    "print(\"Array:\")\n",
    "print(sample_array)\n",
    "print(\"\\nShape:\", sample_array.shape)       # (3, 4) - 3 rows, 4 columns\n",
    "print(\"Dimensions:\", sample_array.ndim)     # 2 dimensions\n",
    "print(\"Size:\", sample_array.size)           # 12 elements total\n",
    "print(\"Data type:\", sample_array.dtype)     # int64 (default integer type)\n",
    "print(\"Item size (bytes):\", sample_array.itemsize)  # 8 bytes per element\n",
    "print(\"Total memory used (bytes):\", sample_array.nbytes)  # 96 bytes total\n",
    "\n",
    "\n",
    "# ### 1.3 Array Indexing and Slicing\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "47330245",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create a sample array\n",
    "arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n",
    "print(\"Original array:\")\n",
    "print(arr)\n",
    "\n",
    "# Indexing\n",
    "print(\"\\nElement at position (0, 0):\", arr[0, 0])   # 1\n",
    "print(\"Element at position (2, 3):\", arr[2, 3])     # 12\n",
    "\n",
    "# Slicing\n",
    "print(\"\\nFirst row:\", arr[0])                        # [1 2 3 4]\n",
    "print(\"First column:\", arr[:, 0])                   # [1 5 9]\n",
    "print(\"Subarray (first 2 rows, first 3 columns):\")\n",
    "print(arr[:2, :3])                                  # [[1 2 3], [5 6 7]]\n",
    "\n",
    "# Fancy indexing\n",
    "print(\"\\nSpecific rows [0, 2]:\")\n",
    "print(arr[[0, 2]])                                  # [[1 2 3 4], [9 10 11 12]]\n",
    "print(\"Specific elements [(0,0), (1,1), (2,2)]:\")\n",
    "print(arr[np.arange(3), np.arange(3)])              # [1 6 11]\n",
    "\n",
    "# Boolean indexing\n",
    "mask = arr > 5\n",
    "print(\"\\nElements greater than 5:\")\n",
    "print(arr[mask])                                    # [6 7 8 9 10 11 12]\n",
    "\n",
    "\n",
    "# ### 1.4 Array Reshaping and Manipulation\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2480efe3",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create a sample array\n",
    "arr = np.arange(12)\n",
    "print(\"Original array:\", arr)\n",
    "\n",
    "# Reshape to 2D array (3x4)\n",
    "arr_reshaped = arr.reshape(3, 4)\n",
    "print(\"\\nReshaped to 3x4:\")\n",
    "print(arr_reshaped)\n",
    "\n",
    "# Reshape to 2D array (4x3)\n",
    "arr_reshaped2 = arr.reshape(4, 3)\n",
    "print(\"\\nReshaped to 4x3:\")\n",
    "print(arr_reshaped2)\n",
    "\n",
    "# Flatten a multi-dimensional array\n",
    "arr_flat = arr_reshaped.flatten()\n",
    "print(\"\\nFlattened array:\", arr_flat)\n",
    "\n",
    "# Transpose (swap rows and columns)\n",
    "arr_transposed = arr_reshaped.T\n",
    "print(\"\\nTransposed array:\")\n",
    "print(arr_transposed)\n",
    "\n",
    "# Stacking arrays\n",
    "a = np.array([1, 2, 3])\n",
    "b = np.array([4, 5, 6])\n",
    "\n",
    "# Vertical stack\n",
    "v_stack = np.vstack((a, b))\n",
    "print(\"\\nVertical stack:\")\n",
    "print(v_stack)\n",
    "\n",
    "# Horizontal stack\n",
    "h_stack = np.hstack((a, b))\n",
    "print(\"\\nHorizontal stack:\", h_stack)\n",
    "\n",
    "# Concatenate\n",
    "concat = np.concatenate((a, b))\n",
    "print(\"\\nConcatenated:\", concat)\n",
    "\n",
    "# Split arrays\n",
    "split_arr = np.split(h_stack, 2)\n",
    "print(\"\\nSplit array into 2 parts:\")\n",
    "for i, arr in enumerate(split_arr):\n",
    "    print(f\"Part {i+1}:\", arr)\n",
    "\n",
    "\n",
    "# ## 2. NumPy Mathematical Operations\n",
    "\n",
    "# ### 2.1 Element-wise Operations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "476644b9",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create sample arrays\n",
    "a = np.array([1, 2, 3, 4])\n",
    "b = np.array([5, 6, 7, 8])\n",
    "\n",
    "# Basic arithmetic operations\n",
    "print(\"a =\", a)\n",
    "print(\"b =\", b)\n",
    "print(\"\\nAddition (a + b):\", a + b)         # [6 8 10 12]\n",
    "print(\"Subtraction (a - b):\", a - b)        # [-4 -4 -4 -4]\n",
    "print(\"Multiplication (a * b):\", a * b)     # [5 12 21 32]\n",
    "print(\"Division (a / b):\", a / b)           # [0.2 0.33 0.43 0.5]\n",
    "print(\"Power (a ** 2):\", a ** 2)            # [1 4 9 16]\n",
    "\n",
    "# More arithmetic operations\n",
    "print(\"\\nSquare root:\", np.sqrt(a))         # [1. 1.41 1.73 2.]\n",
    "print(\"Exponential (e^a):\", np.exp(a))      # [2.72 7.39 20.09 54.6]\n",
    "print(\"Natural logarithm:\", np.log(a))      # [0. 0.69 1.1 1.39]\n",
    "print(\"Sine:\", np.sin(a))                   # [0.84 0.91 0.14 -0.76]\n",
    "print(\"Absolute value of -a:\", np.abs(-a))  # [1 2 3 4]\n",
    "\n",
    "\n",
    "# ### 2.2 Array-wise Operations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "382c7ca3",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create a sample array\n",
    "arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n",
    "print(\"Array:\")\n",
    "print(arr)\n",
    "\n",
    "# Sum, min, max, mean\n",
    "print(\"\\nSum of all elements:\", arr.sum())             # 45\n",
    "print(\"Minimum element:\", arr.min())                   # 1\n",
    "print(\"Maximum element:\", arr.max())                   # 9\n",
    "print(\"Mean of all elements:\", arr.mean())             # 5.0\n",
    "print(\"Standard deviation:\", arr.std())                # 2.58...\n",
    "\n",
    "# Operations along axes\n",
    "print(\"\\nSum along rows (axis=0):\", arr.sum(axis=0))   # [12 15 18]\n",
    "print(\"Sum along columns (axis=1):\", arr.sum(axis=1))  # [6 15 24]\n",
    "print(\"Min along rows:\", arr.min(axis=0))              # [1 2 3]\n",
    "print(\"Max along columns:\", arr.max(axis=1))           # [3 6 9]\n",
    "\n",
    "\n",
    "# ### 2.3 Broadcasting\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "edaedfdd",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Broadcasting allows NumPy to work with arrays of different shapes\n",
    "# when performing arithmetic operations\n",
    "\n",
    "# Example 1: Array + scalar\n",
    "arr = np.array([[1, 2, 3], [4, 5, 6]])\n",
    "print(\"Array:\")\n",
    "print(arr)\n",
    "print(\"\\nArray + 10:\")\n",
    "print(arr + 10)  # Adds 10 to each element\n",
    "\n",
    "# Example 2: Array + vector\n",
    "row_vector = np.array([10, 20, 30])\n",
    "print(\"\\nRow vector:\", row_vector)\n",
    "print(\"Array + row vector:\")\n",
    "print(arr + row_vector)  # Adds vector to each row\n",
    "\n",
    "# Example 3: Array + column vector\n",
    "col_vector = np.array([[100], [200]])\n",
    "print(\"\\nColumn vector:\")\n",
    "print(col_vector)\n",
    "print(\"Array + column vector:\")\n",
    "print(arr + col_vector)  # Adds vector to each column\n",
    "\n",
    "\n",
    "# ### 2.4 Linear Algebra Operations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9446f1cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create sample matrices\n",
    "A = np.array([[1, 2], [3, 4]])\n",
    "B = np.array([[5, 6], [7, 8]])\n",
    "v = np.array([1, 2])\n",
    "\n",
    "print(\"Matrix A:\")\n",
    "print(A)\n",
    "print(\"\\nMatrix B:\")\n",
    "print(B)\n",
    "print(\"\\nVector v:\", v)\n",
    "\n",
    "# Matrix multiplication\n",
    "print(\"\\nMatrix multiplication (A @ B):\")\n",
    "print(A @ B)  # or np.matmul(A, B) or A.dot(B)\n",
    "\n",
    "# Matrix-vector multiplication\n",
    "print(\"\\nMatrix-vector multiplication (A @ v):\")\n",
    "print(A @ v)  # or np.matmul(A, v) or A.dot(v)\n",
    "\n",
    "# Determinant\n",
    "print(\"\\nDeterminant of A:\", np.linalg.det(A))\n",
    "\n",
    "# Matrix inverse\n",
    "print(\"\\nInverse of A:\")\n",
    "print(np.linalg.inv(A))\n",
    "\n",
    "# Eigenvalues and eigenvectors\n",
    "eigenvalues, eigenvectors = np.linalg.eig(A)\n",
    "print(\"\\nEigenvalues of A:\", eigenvalues)\n",
    "print(\"Eigenvectors of A:\")\n",
    "print(eigenvectors)\n",
    "\n",
    "# Solving linear system Ax = b\n",
    "b = np.array([5, 11])\n",
    "x = np.linalg.solve(A, b)\n",
    "print(\"\\nSolution to Ax = b where b =\", b)\n",
    "print(\"x =\", x)\n",
    "print(\"Verification A @ x =\", A @ x)  # Should equal b\n",
    "\n",
    "\n",
    "# ## 3. Real-world Applications of NumPy in Machine Learning\n",
    "\n",
    "# ### 3.1 Data Preprocessing\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "36d0e365",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate sample data\n",
    "np.random.seed(42)  # For reproducibility\n",
    "data = np.random.normal(0, 1, (100, 5))  # 100 samples, 5 features\n",
    "print(\"Original data shape:\", data.shape)\n",
    "print(\"First 5 samples:\")\n",
    "print(data[:5])\n",
    "\n",
    "# Standardization (z-score normalization)\n",
    "mean = data.mean(axis=0)\n",
    "std = data.std(axis=0)\n",
    "standardized_data = (data - mean) / std\n",
    "\n",
    "print(\"\\nStandardized data (first 5 samples):\")\n",
    "print(standardized_data[:5])\n",
    "print(\"Mean of standardized data:\", standardized_data.mean(axis=0))\n",
    "print(\"Std of standardized data:\", standardized_data.std(axis=0))\n",
    "\n",
    "# Min-Max scaling\n",
    "min_vals = data.min(axis=0)\n",
    "max_vals = data.max(axis=0)\n",
    "normalized_data = (data - min_vals) / (max_vals - min_vals)\n",
    "\n",
    "print(\"\\nNormalized data (first 5 samples):\")\n",
    "print(normalized_data[:5])\n",
    "print(\"Min of normalized data:\", normalized_data.min(axis=0))\n",
    "print(\"Max of normalized data:\", normalized_data.max(axis=0))\n",
    "\n",
    "\n",
    "# ### 3.2 Principal Component Analysis (PCA) Implementation\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84c5219a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate sample data\n",
    "np.random.seed(42)\n",
    "# Create correlated data\n",
    "cov_matrix = np.array([[1, 0.8], [0.8, 1]])\n",
    "data = np.random.multivariate_normal([0, 0], cov_matrix, 100)\n",
    "\n",
    "print(\"Original data shape:\", data.shape)\n",
    "print(\"First 5 samples:\")\n",
    "print(data[:5])\n",
    "\n",
    "# Step 1: Center the data\n",
    "data_centered = data - data.mean(axis=0)\n",
    "\n",
    "# Step 2: Compute the covariance matrix\n",
    "cov_mat = np.cov(data_centered, rowvar=False)\n",
    "print(\"\\nCovariance matrix:\")\n",
    "print(cov_mat)\n",
    "\n",
    "# Step 3: Compute eigenvalues and eigenvectors\n",
    "eigenvalues, eigenvectors = np.linalg.eig(cov_mat)\n",
    "print(\"\\nEigenvalues:\", eigenvalues)\n",
    "print(\"Eigenvectors:\")\n",
    "print(eigenvectors)\n",
    "\n",
    "# Step 4: Sort eigenvectors by eigenvalues in descending order\n",
    "idx = eigenvalues.argsort()[::-1]\n",
    "eigenvalues = eigenvalues[idx]\n",
    "eigenvectors = eigenvectors[:, idx]\n",
    "\n",
    "# Step 5: Project data onto principal components\n",
    "n_components = 1  # Reduce to 1 dimension\n",
    "pca_data = data_centered @ eigenvectors[:, :n_components]\n",
    "\n",
    "print(\"\\nData after PCA (first 5 samples):\")\n",
    "print(pca_data[:5])\n",
    "print(\"Explained variance ratio:\", eigenvalues[0] / np.sum(eigenvalues))\n",
    "\n",
    "\n",
    "# ### 3.3 Implementing a Simple Neural Network Layer\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ad4c3a7",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Define a simple neural network forward pass function\n",
    "def neural_network_layer(X, W, b, activation='relu'):\n",
    "    \"\"\"\n",
    "    Implements a single neural network layer\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    X : ndarray, shape (n_samples, n_features)\n",
    "        Input data\n",
    "    W : ndarray, shape (n_features, n_neurons)\n",
    "        Weight matrix\n",
    "    b : ndarray, shape (n_neurons,)\n",
    "        Bias vector\n",
    "    activation : str, default='relu'\n",
    "        Activation function to use ('relu' or 'sigmoid')\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    A : ndarray, shape (n_samples, n_neurons)\n",
    "        Output activations\n",
    "    \"\"\"\n",
    "    # Linear transformation: Z = X @ W + b\n",
    "    Z = X @ W + b\n",
    "    \n",
    "    # Apply activation function\n",
    "    if activation == 'relu':\n",
    "        # ReLU activation: max(0, Z)\n",
    "        A = np.maximum(0, Z)\n",
    "    elif activation == 'sigmoid':\n",
    "        # Sigmoid activation: 1 / (1 + exp(-Z))\n",
    "        A = 1 / (1 + np.exp(-Z))\n",
    "    else:\n",
    "        raise ValueError(f\"Unsupported activation function: {activation}\")\n",
    "    \n",
    "    return A\n",
    "\n",
    "# Generate random data\n",
    "np.random.seed(42)\n",
    "X = np.random.randn(5, 3)  # 5 samples, 3 features\n",
    "W = np.random.randn(3, 4)  # 3 input features, 4 neurons\n",
    "b = np.random.randn(4)     # 4 neurons\n",
    "\n",
    "print(\"Input data X:\")\n",
    "print(X)\n",
    "print(\"\\nWeight matrix W:\")\n",
    "print(W)\n",
    "print(\"\\nBias vector b:\", b)\n",
    "\n",
    "# Forward pass with ReLU activation\n",
    "output_relu = neural_network_layer(X, W, b, activation='relu')\n",
    "print(\"\\nOutput with ReLU activation:\")\n",
    "print(output_relu)\n",
    "\n",
    "# Forward pass with Sigmoid activation\n",
    "output_sigmoid = neural_network_layer(X, W, b, activation='sigmoid')\n",
    "print(\"\\nOutput with Sigmoid activation:\")\n",
    "print(output_sigmoid)\n",
    "\n",
    "\n",
    "# ### 3.4 Implementing Batch Gradient Descent\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3010cdf7",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Define a simple linear regression model with batch gradient descent\n",
    "def batch_gradient_descent(X, y, learning_rate=0.01, n_iterations=1000):\n",
    "    \"\"\"\n",
    "    Implements batch gradient descent for linear regression\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    X : ndarray, shape (n_samples, n_features)\n",
    "        Input features\n",
    "    y : ndarray, shape (n_samples,)\n",
    "        Target values\n",
    "    learning_rate : float, default=0.01\n",
    "        Learning rate for gradient descent\n",
    "    n_iterations : int, default=1000\n",
    "        Number of iterations\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    weights : ndarray, shape (n_features,)\n",
    "        Learned weights\n",
    "    bias : float\n",
    "        Learned bias\n",
    "    costs : list\n",
    "        Cost history\n",
    "    \"\"\"\n",
    "    n_samples, n_features = X.shape\n",
    "    \n",
    "    # Initialize weights and bias\n",
    "    weights = np.zeros(n_features)\n",
    "    bias = 0\n",
    "    costs = []\n",
    "    \n",
    "    # Gradient descent\n",
    "    for i in range(n_iterations):\n",
    "        # Forward pass: predictions\n",
    "        y_pred = X @ weights + bias\n",
    "        \n",
    "        # Compute cost (MSE)\n",
    "        cost = np.mean((y_pred - y) ** 2)\n",
    "        costs.append(cost)\n",
    "        \n",
    "        # Compute gradients\n",
    "        dw = (2/n_samples) * X.T @ (y_pred - y)\n",
    "        db = (2/n_samples) * np.sum(y_pred - y)\n",
    "        \n",
    "        # Update parameters\n",
    "        weights -= learning_rate * dw\n",
    "        bias -= learning_rate * db\n",
    "        \n",
    "        # Print progress\n",
    "        if i % 100 == 0:\n",
    "            print(f\"Iteration {i}, Cost: {cost:.4f}\")\n",
    "    \n",
    "    return weights, bias, costs\n",
    "\n",
    "# Generate synthetic data\n",
    "np.random.seed(42)\n",
    "X = 2 * np.random.rand(100, 1)\n",
    "y = 4 + 3 * X + np.random.randn(100, 1).flatten()\n",
    "\n",
    "print(\"X shape:\", X.shape)\n",
    "print(\"y shape:\", y.shape)\n",
    "\n",
    "# Train the model\n",
    "weights, bias, costs = batch_gradient_descent(X, y, learning_rate=0.01, n_iterations=1000)\n",
    "\n",
    "print(\"\\nLearned weights:\", weights)\n",
    "print(\"Learned bias:\", bias)\n",
    "print(\"Final cost:\", costs[-1])\n",
    "\n",
    "# Make predictions\n",
    "X_new = np.array([[0], [2]])\n",
    "y_pred = X_new @ weights + bias\n",
    "print(\"\\nPredictions for X =\", X_new.flatten())\n",
    "print(\"y_pred =\", y_pred)\n",
    "\n",
    "\n",
    "# ## 4. Test Your Knowledge\n",
    "\n",
    "# ### Exercise 1: Array Creation and Manipulation\n",
    "# \n",
    "# 1. Create a 3x3 array of random integers between 1 and 10.\n",
    "# 2. Find the sum, mean, and standard deviation of the array.\n",
    "# 3. Extract the diagonal elements of the array.\n",
    "# 4. Reshape the array into a 1D array and then back to a 3x3 array.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91a9bff0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "# 1. Create a 3x3 array of random integers between 1 and 10\n",
    "random_array = np.random.randint(1, 11, (3, 3))\n",
    "print(\"Random array:\")\n",
    "print(random_array)\n",
    "\n",
    "# 2. Find the sum, mean, and standard deviation\n",
    "print(\"\\nSum:\", random_array.sum())\n",
    "print(\"Mean:\", random_array.mean())\n",
    "print(\"Standard deviation:\", random_array.std())\n",
    "\n",
    "# 3. Extract the diagonal elements\n",
    "diag = np.diag(random_array)\n",
    "print(\"\\nDiagonal elements:\", diag)\n",
    "\n",
    "# 4. Reshape to 1D and back to 3x3\n",
    "reshaped_1d = random_array.reshape(-1)\n",
    "print(\"\\nReshaped to 1D:\", reshaped_1d)\n",
    "reshaped_3x3 = reshaped_1d.reshape(3, 3)\n",
    "print(\"\\nReshaped back to 3x3:\")\n",
    "print(reshaped_3x3)\n",
    "\n",
    "\n",
    "# ### Exercise 2: Broadcasting and Operations\n",
    "# \n",
    "# 1. Create a 4x3 array of random numbers.\n",
    "# 2. Compute the mean of each column.\n",
    "# 3. Subtract the column means from each element in the corresponding column.\n",
    "# 4. Verify that the mean of each column in the resulting array is close to zero.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6100a364",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "# 1. Create a 4x3 array of random numbers\n",
    "random_array = np.random.rand(4, 3)\n",
    "print(\"Random array:\")\n",
    "print(random_array)\n",
    "\n",
    "# 2. Compute the mean of each column\n",
    "col_means = random_array.mean(axis=0)\n",
    "print(\"\\nColumn means:\", col_means)\n",
    "\n",
    "# 3. Subtract the column means from each element\n",
    "centered_array = random_array - col_means\n",
    "print(\"\\nCentered array:\")\n",
    "print(centered_array)\n",
    "\n",
    "# 4. Verify that the mean of each column is close to zero\n",
    "new_means = centered_array.mean(axis=0)\n",
    "print(\"\\nNew column means:\", new_means)\n",
    "print(\"Are the new means close to zero?\", np.allclose(new_means, 0))\n",
    "\n",
    "\n",
    "# ### Exercise 3: Linear Algebra\n",
    "# \n",
    "# 1. Create two 2x2 matrices A and B.\n",
    "# 2. Compute the matrix product A @ B.\n",
    "# 3. Compute the determinant of A.\n",
    "# 4. Solve the linear system Ax = b, where b is a vector [1, 2].\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62a2921d",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "# 1. Create two 2x2 matrices\n",
    "A = np.array([[2, 1], [3, 4]])\n",
    "B = np.array([[1, 0], [2, 3]])\n",
    "print(\"Matrix A:\")\n",
    "print(A)\n",
    "print(\"\\nMatrix B:\")\n",
    "print(B)\n",
    "\n",
    "# 2. Compute the matrix product\n",
    "C = A @ B\n",
    "print(\"\\nMatrix product A @ B:\")\n",
    "print(C)\n",
    "\n",
    "# 3. Compute the determinant of A\n",
    "det_A = np.linalg.det(A)\n",
    "print(\"\\nDeterminant of A:\", det_A)\n",
    "\n",
    "# 4. Solve the linear system Ax = b\n",
    "b = np.array([1, 2])\n",
    "x = np.linalg.solve(A, b)\n",
    "print(\"\\nSolution to Ax = b where b =\", b)\n",
    "print(\"x =\", x)\n",
    "print(\"Verification A @ x =\", A @ x)  # Should equal b\n",
    "\n",
    "\n",
    "# ### Exercise 4: Implementing a Simple Machine Learning Algorithm\n",
    "# \n",
    "# Implement k-means clustering from scratch using NumPy:\n",
    "# \n",
    "# 1. Generate random data with 3 clusters.\n",
    "# 2. Initialize 3 random centroids.\n",
    "# 3. Implement the k-means algorithm to find the clusters.\n",
    "# 4. Plot the results (you can use matplotlib for this).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f9670566",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution (without plotting):\n",
    "def kmeans(X, k, max_iters=100):\n",
    "    \"\"\"\n",
    "    Implements k-means clustering algorithm\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    X : ndarray, shape (n_samples, n_features)\n",
    "        Input data\n",
    "    k : int\n",
    "        Number of clusters\n",
    "    max_iters : int, default=100\n",
    "        Maximum number of iterations\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    centroids : ndarray, shape (k, n_features)\n",
    "        Final centroids\n",
    "    labels : ndarray, shape (n_samples,)\n",
    "        Cluster assignments for each sample\n",
    "    \"\"\"\n",
    "    n_samples, n_features = X.shape\n",
    "    \n",
    "    # Initialize centroids randomly\n",
    "    idx = np.random.choice(n_samples, k, replace=False)\n",
    "    centroids = X[idx]\n",
    "    \n",
    "    # Initialize labels\n",
    "    labels = np.zeros(n_samples)\n",
    "    \n",
    "    # Main loop\n",
    "    for _ in range(max_iters):\n",
    "        # Assign samples to closest centroids\n",
    "        distances = np.zeros((n_samples, k))\n",
    "        for i in range(k):\n",
    "            # Compute Euclidean distance\n",
    "            distances[:, i] = np.sqrt(np.sum((X - centroids[i])**2, axis=1))\n",
    "        \n",
    "        new_labels = np.argmin(distances, axis=1)\n",
    "        \n",
    "        # Check for convergence\n",
    "        if np.all(labels == new_labels):\n",
    "            break\n",
    "        \n",
    "        labels = new_labels\n",
    "        \n",
    "        # Update centroids\n",
    "        for i in range(k):\n",
    "            mask = labels == i\n",
    "            if np.any(mask):\n",
    "                centroids[i] = X[mask].mean(axis=0)\n",
    "    \n",
    "    return centroids, labels\n",
    "\n",
    "# Generate random data with 3 clusters\n",
    "np.random.seed(42)\n",
    "n_samples_per_cluster = 100\n",
    "cluster1 = np.random.randn(n_samples_per_cluster, 2) + np.array([3, 3])\n",
    "cluster2 = np.random.randn(n_samples_per_cluster, 2) + np.array([-3, -3])\n",
    "cluster3 = np.random.randn(n_samples_per_cluster, 2) + np.array([3, -3])\n",
    "X = np.vstack([cluster1, cluster2, cluster3])\n",
    "\n",
    "print(\"Data shape:\", X.shape)\n",
    "\n",
    "# Run k-means\n",
    "centroids, labels = kmeans(X, k=3)\n",
    "\n",
    "print(\"\\nFinal centroids:\")\n",
    "print(centroids)\n",
    "print(\"\\nCluster counts:\")\n",
    "for i in range(3):\n",
    "    print(f\"Cluster {i}: {np.sum(labels == i)} samples\")\n",
    "\n",
    "\n",
    "# ## 5. Additional Resources\n",
    "# \n",
    "# - [NumPy Documentation](https://numpy.org/doc/stable/)\n",
    "# - [NumPy Cheat Sheet](https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Numpy_Python_Cheat_Sheet.pdf)\n",
    "# - [NumPy Tutorials](https://numpy.org/numpy-tutorials/)\n",
    "# - [NumPy ML Implementations](https://github.com/ddbourgin/numpy-ml)\n",
    "# - [From Python to NumPy](https://www.labri.fr/perso/nrougier/from-python-to-numpy/)\n",
    "#!/usr/bin/env python\n",
    "# coding: utf-8\n",
    "\n",
