    "# # Matplotlib: Data Visualization in Python\n",
    "# \n",
    "# ## Introduction\n",
    "# \n",
    "# Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. It provides a MATLAB-like interface, particularly when used with the pyplot module. Matplotlib is the foundation for many other visualization libraries in Python.\n",
    "# \n",
    "# This section will introduce you to the most essential Matplotlib concepts and functions that are widely used in machine learning and data science projects for creating professional visualizations.\n",
    "# \n",
    "# **Source:** [Matplotlib Documentation](https://matplotlib.org/stable/index.html) and [Data Visualization with Matplotlib](https://github.com/pb111/Data-Analysis-and-Visualization-with-Python/blob/master/Matplotlib_Basics.ipynb)\n",
    "\n",
    "# ## Why Matplotlib?\n",
    "# \n",
    "# Matplotlib is a powerful tool for data visualization because:\n",
    "# \n",
    "# - It provides a high level of control over every element of a plot\n",
    "# - It can create publication-quality figures in various formats\n",
    "# - It works well with NumPy and Pandas\n",
    "# - It integrates with various GUI toolkits\n",
    "# - It serves as the foundation for other visualization libraries like Seaborn\n",
    "# \n",
    "# These capabilities make Matplotlib the go-to library for customized data visualization in machine learning workflows.\n",
    "# \n",
    "# **Source:** [Python Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/04.00-introduction-to-matplotlib.html)\n",
    "\n",
    "# ## 1. Matplotlib Basics\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2c8fe074",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib as mpl\n",
    "\n",
    "# Set the style\n",
    "plt.style.use('ggplot')\n",
    "\n",
    "# For inline plotting in Jupyter notebooks\n",
    "# %matplotlib inline\n",
    "\n",
    "\n",
    "# ### 1.1 Figure and Axes\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f417285",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Creating a simple figure and axes\n",
    "fig, ax = plt.subplots(figsize=(10, 6))\n",
    "ax.plot([1, 2, 3, 4], [1, 4, 2, 3])\n",
    "ax.set_title('Simple Line Plot')\n",
    "ax.set_xlabel('X-axis')\n",
    "ax.set_ylabel('Y-axis')\n",
    "plt.show()\n",
    "\n",
    "# Creating multiple subplots\n",
    "fig, axes = plt.subplots(2, 2, figsize=(12, 8))\n",
    "axes[0, 0].plot([1, 2, 3, 4], [1, 4, 2, 3])\n",
    "axes[0, 0].set_title('Plot 1')\n",
    "axes[0, 1].plot([1, 2, 3, 4], [1, 2, 4, 8])\n",
    "axes[0, 1].set_title('Plot 2')\n",
    "axes[1, 0].plot([1, 2, 3, 4], [4, 3, 2, 1])\n",
    "axes[1, 0].set_title('Plot 3')\n",
    "axes[1, 1].plot([1, 2, 3, 4], [10, 20, 30, 40])\n",
    "axes[1, 1].set_title('Plot 4')\n",
    "\n",
    "# Adjust layout\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Creating a figure with specified size and DPI\n",
    "fig = plt.figure(figsize=(10, 6), dpi=100)\n",
    "ax = fig.add_subplot(111)  # 1 row, 1 column, 1st subplot\n",
    "ax.plot([1, 2, 3, 4], [1, 4, 2, 3])\n",
    "ax.set_title('Custom Figure Size and DPI')\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 1.2 Basic Plotting\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f023e3e1",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate some data\n",
    "x = np.linspace(0, 10, 100)\n",
    "y1 = np.sin(x)\n",
    "y2 = np.cos(x)\n",
    "y3 = np.exp(-x/10) * np.sin(x)\n",
    "\n",
    "# Line plot\n",
    "plt.figure(figsize=(12, 8))\n",
    "plt.plot(x, y1, label='sin(x)')\n",
    "plt.plot(x, y2, label='cos(x)')\n",
    "plt.plot(x, y3, label='exp(-x/10)*sin(x)')\n",
    "plt.title('Basic Line Plot')\n",
    "plt.xlabel('x')\n",
    "plt.ylabel('y')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "# Scatter plot\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.scatter(x[::5], y1[::5], c='blue', s=50, alpha=0.7, label='sin(x)')\n",
    "plt.scatter(x[::5], y2[::5], c='red', s=50, alpha=0.7, label='cos(x)')\n",
    "plt.title('Scatter Plot')\n",
    "plt.xlabel('x')\n",
    "plt.ylabel('y')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "# Bar plot\n",
    "categories = ['A', 'B', 'C', 'D', 'E']\n",
    "values = [25, 40, 30, 55, 15]\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.bar(categories, values, color='skyblue', edgecolor='black')\n",
    "plt.title('Bar Plot')\n",
    "plt.xlabel('Categories')\n",
    "plt.ylabel('Values')\n",
    "plt.grid(axis='y')\n",
    "plt.show()\n",
    "\n",
    "# Histogram\n",
    "data = np.random.normal(0, 1, 1000)\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.hist(data, bins=30, color='skyblue', edgecolor='black', alpha=0.7)\n",
    "plt.title('Histogram')\n",
    "plt.xlabel('Value')\n",
    "plt.ylabel('Frequency')\n",
    "plt.grid(axis='y')\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 1.3 Customizing Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4c877cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate some data\n",
    "x = np.linspace(0, 10, 100)\n",
    "y1 = np.sin(x)\n",
    "y2 = np.cos(x)\n",
    "\n",
    "# Line styles, colors, and markers\n",
    "plt.figure(figsize=(12, 8))\n",
    "plt.plot(x, y1, 'b-', linewidth=2, label='sin(x)')  # blue solid line\n",
    "plt.plot(x, y2, 'r--', linewidth=2, label='cos(x)')  # red dashed line\n",
    "plt.plot(x, y1 + y2, 'g-.', linewidth=2, label='sin(x) + cos(x)')  # green dash-dot line\n",
    "plt.plot(x, y1 - y2, 'k:', linewidth=2, label='sin(x) - cos(x)')  # black dotted line\n",
    "\n",
    "# Markers at specific points\n",
    "plt.plot(x[::10], y1[::10], 'bo', markersize=8)  # blue circles\n",
    "plt.plot(x[::10], y2[::10], 'rs', markersize=8)  # red squares\n",
    "\n",
    "plt.title('Customized Line Styles, Colors, and Markers', fontsize=16)\n",
    "plt.xlabel('x', fontsize=14)\n",
    "plt.ylabel('y', fontsize=14)\n",
    "plt.legend(fontsize=12)\n",
    "plt.grid(True, linestyle='--', alpha=0.7)\n",
    "\n",
    "# Customize axis limits\n",
    "plt.xlim(0, 10)\n",
    "plt.ylim(-1.5, 1.5)\n",
    "\n",
    "# Customize tick marks\n",
    "plt.xticks(np.arange(0, 11, 1), fontsize=12)\n",
    "plt.yticks(np.arange(-1.5, 1.6, 0.5), fontsize=12)\n",
    "\n",
    "plt.show()\n",
    "\n",
    "# Customizing text and annotations\n",
    "plt.figure(figsize=(12, 8))\n",
    "plt.plot(x, y1, 'b-', linewidth=2, label='sin(x)')\n",
    "\n",
    "# Add text at specific positions\n",
    "plt.text(2, 0.8, 'Local Maximum', fontsize=12, ha='center')\n",
    "plt.text(7, -0.8, 'Local Minimum', fontsize=12, ha='center')\n",
    "\n",
    "# Add annotations with arrows\n",
    "plt.annotate('Important Point', xy=(4.7, 0), xytext=(5.5, 0.5),\n",
    "             arrowprops=dict(facecolor='black', shrink=0.05, width=1.5),\n",
    "             fontsize=12)\n",
    "\n",
    "plt.title('Text and Annotations', fontsize=16)\n",
    "plt.xlabel('x', fontsize=14)\n",
    "plt.ylabel('y', fontsize=14)\n",
    "plt.legend(fontsize=12)\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "# Customizing figure style\n",
    "with plt.style.context('seaborn-darkgrid'):\n",
    "    plt.figure(figsize=(12, 8))\n",
    "    plt.plot(x, y1, 'b-', linewidth=2, label='sin(x)')\n",
    "    plt.plot(x, y2, 'r--', linewidth=2, label='cos(x)')\n",
    "    plt.title('Plot with Seaborn Dark Grid Style', fontsize=16)\n",
    "    plt.xlabel('x', fontsize=14)\n",
    "    plt.ylabel('y', fontsize=14)\n",
    "    plt.legend(fontsize=12)\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "# ### 1.4 Saving Figures\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4cf8ac7",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Create a figure\n",
    "fig, ax = plt.subplots(figsize=(10, 6))\n",
    "ax.plot([1, 2, 3, 4], [1, 4, 2, 3], 'r-', linewidth=2)\n",
    "ax.set_title('Figure to Save')\n",
    "ax.set_xlabel('X-axis')\n",
    "ax.set_ylabel('Y-axis')\n",
    "\n",
    "# Save in different formats\n",
    "# fig.savefig('figure.png', dpi=300, bbox_inches='tight')  # PNG format\n",
    "# fig.savefig('figure.pdf', bbox_inches='tight')  # PDF format\n",
    "# fig.savefig('figure.svg', bbox_inches='tight')  # SVG format\n",
    "# fig.savefig('figure.jpg', dpi=300, bbox_inches='tight', quality=90)  # JPEG format\n",
    "\n",
    "plt.show()\n",
    "\n",
    "# Code to save with transparent background\n",
    "# fig.savefig('figure_transparent.png', dpi=300, bbox_inches='tight', transparent=True)\n",
    "\n",
    "\n",
    "# ## 2. Plot Types and Visualization Techniques\n",
    "\n",
    "# ### 2.1 Statistical Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d2ee9f6f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate some random data\n",
    "np.random.seed(42)\n",
    "data1 = np.random.normal(0, 1, 1000)\n",
    "data2 = np.random.normal(2, 1.5, 1000)\n",
    "data3 = np.random.normal(-2, 2, 1000)\n",
    "\n",
    "# Histogram with KDE (Kernel Density Estimation)\n",
    "plt.figure(figsize=(12, 8))\n",
    "plt.hist(data1, bins=30, alpha=0.5, density=True, label='Data 1')\n",
    "plt.hist(data2, bins=30, alpha=0.5, density=True, label='Data 2')\n",
    "plt.hist(data3, bins=30, alpha=0.5, density=True, label='Data 3')\n",
    "\n",
    "# Add KDE curves\n",
    "from scipy import stats\n",
    "x = np.linspace(-8, 8, 1000)\n",
    "for data, color in zip([data1, data2, data3], ['blue', 'orange', 'green']):\n",
    "    kde = stats.gaussian_kde(data)\n",
    "    plt.plot(x, kde(x), color=color, linewidth=2)\n",
    "\n",
    "plt.title('Histogram with Kernel Density Estimation', fontsize=16)\n",
    "plt.xlabel('Value', fontsize=14)\n",
    "plt.ylabel('Density', fontsize=14)\n",
    "plt.legend(fontsize=12)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Box plot\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.boxplot([data1, data2, data3], labels=['Data 1', 'Data 2', 'Data 3'], \n",
    "           patch_artist=True, boxprops=dict(facecolor='lightblue'))\n",
    "plt.title('Box Plot', fontsize=16)\n",
    "plt.ylabel('Value', fontsize=14)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Violin plot\n",
    "plt.figure(figsize=(10, 6))\n",
    "parts = plt.violinplot([data1, data2, data3], showmeans=True, showmedians=True)\n",
    "\n",
    "# Customize violin plot colors\n",
    "for i, pc in enumerate(parts['bodies']):\n",
    "    pc.set_facecolor(['lightblue', 'lightgreen', 'salmon'][i % 3])\n",
    "    pc.set_edgecolor('black')\n",
    "    pc.set_alpha(0.7)\n",
    "\n",
    "plt.title('Violin Plot', fontsize=16)\n",
    "plt.xticks([1, 2, 3], ['Data 1', 'Data 2', 'Data 3'], fontsize=12)\n",
    "plt.ylabel('Value', fontsize=14)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 2.2 Contour and Surface Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8501bc3f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate 2D data for contour and surface plots\n",
    "x = np.linspace(-5, 5, 100)\n",
    "y = np.linspace(-5, 5, 100)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "Z = np.sin(np.sqrt(X**2 + Y**2))\n",
    "\n",
    "# Contour plot\n",
    "plt.figure(figsize=(10, 8))\n",
    "contour = plt.contour(X, Y, Z, 20, cmap='viridis')\n",
    "plt.colorbar(contour, label='Z Value')\n",
    "plt.title('Contour Plot', fontsize=16)\n",
    "plt.xlabel('X', fontsize=14)\n",
    "plt.ylabel('Y', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Filled contour plot\n",
    "plt.figure(figsize=(10, 8))\n",
    "contourf = plt.contourf(X, Y, Z, 20, cmap='viridis')\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Filled Contour Plot', fontsize=16)\n",
    "plt.xlabel('X', fontsize=14)\n",
    "plt.ylabel('Y', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# 3D Surface plot\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "fig = plt.figure(figsize=(12, 10))\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "surface = ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none', alpha=0.8)\n",
    "fig.colorbar(surface, ax=ax, shrink=0.5, aspect=5, label='Z Value')\n",
    "ax.set_title('3D Surface Plot', fontsize=16)\n",
    "ax.set_xlabel('X', fontsize=14)\n",
    "ax.set_ylabel('Y', fontsize=14)\n",
    "ax.set_zlabel('Z', fontsize=14)\n",
    "plt.show()\n",
    "\n",
    "# 3D Wire frame plot\n",
    "fig = plt.figure(figsize=(12, 10))\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "wireframe = ax.plot_wireframe(X, Y, Z, rstride=5, cstride=5, color='blue', linewidth=0.5)\n",
    "ax.set_title('3D Wire Frame Plot', fontsize=16)\n",
    "ax.set_xlabel('X', fontsize=14)\n",
    "ax.set_ylabel('Y', fontsize=14)\n",
    "ax.set_zlabel('Z', fontsize=14)\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 2.3 Heatmaps and Image Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f8843d4",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate data for heatmap\n",
    "np.random.seed(42)\n",
    "data = np.random.rand(10, 12)\n",
    "\n",
    "# Heatmap\n",
    "plt.figure(figsize=(12, 8))\n",
    "heatmap = plt.imshow(data, cmap='viridis', interpolation='nearest')\n",
    "plt.colorbar(heatmap, label='Value')\n",
    "plt.title('Basic Heatmap', fontsize=16)\n",
    "plt.xlabel('Column', fontsize=14)\n",
    "plt.ylabel('Row', fontsize=14)\n",
    "plt.xticks(np.arange(data.shape[1]))\n",
    "plt.yticks(np.arange(data.shape[0]))\n",
    "plt.grid(False)\n",
    "plt.show()\n",
    "\n",
    "# Heatmap with annotations\n",
    "plt.figure(figsize=(12, 8))\n",
    "heatmap = plt.imshow(data, cmap='YlOrRd', interpolation='nearest')\n",
    "plt.colorbar(heatmap, label='Value')\n",
    "plt.title('Heatmap with Annotations', fontsize=16)\n",
    "plt.xlabel('Column', fontsize=14)\n",
    "plt.ylabel('Row', fontsize=14)\n",
    "\n",
    "# Add text annotations\n",
    "for i in range(data.shape[0]):\n",
    "    for j in range(data.shape[1]):\n",
    "        plt.text(j, i, f'{data[i, j]:.2f}', \n",
    "                 ha='center', va='center', \n",
    "                 color='white' if data[i, j] > 0.5 else 'black',\n",
    "                 fontsize=9)\n",
    "\n",
    "plt.xticks(np.arange(data.shape[1]))\n",
    "plt.yticks(np.arange(data.shape[0]))\n",
    "plt.grid(False)\n",
    "plt.show()\n",
    "\n",
    "# Correlation matrix heatmap\n",
    "from sklearn.datasets import load_iris\n",
    "iris = load_iris()\n",
    "df = pd.DataFrame(iris.data, columns=iris.feature_names)\n",
    "correlation = df.corr()\n",
    "\n",
    "plt.figure(figsize=(10, 8))\n",
    "heatmap = plt.imshow(correlation, cmap='coolwarm', interpolation='nearest')\n",
    "plt.colorbar(heatmap, label='Correlation Coefficient')\n",
    "plt.title('Correlation Matrix Heatmap', fontsize=16)\n",
    "plt.xticks(np.arange(correlation.shape[1]), correlation.columns, rotation=45, ha='right')\n",
    "plt.yticks(np.arange(correlation.shape[0]), correlation.columns)\n",
    "\n",
    "# Add text annotations\n",
    "for i in range(correlation.shape[0]):\n",
    "    for j in range(correlation.shape[1]):\n",
    "        plt.text(j, i, f'{correlation.iloc[i, j]:.2f}', \n",
    "                 ha='center', va='center', \n",
    "                 color='white' if abs(correlation.iloc[i, j]) > 0.7 else 'black',\n",
    "                 fontsize=9)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 2.4 Specialized Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ddc57119",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Pie chart\n",
    "labels = ['A', 'B', 'C', 'D', 'E']\n",
    "sizes = [15, 30, 25, 10, 20]\n",
    "explode = (0, 0.1, 0, 0, 0)  # explode the 2nd slice\n",
    "\n",
    "plt.figure(figsize=(10, 8))\n",
    "plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',\n",
    "        shadow=True, startangle=90, colors=plt.cm.Paired.colors)\n",
    "plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle\n",
    "plt.title('Pie Chart', fontsize=16)\n",
    "plt.show()\n",
    "\n",
    "# Polar plot\n",
    "theta = np.linspace(0, 2*np.pi, 100)\n",
    "r = np.abs(np.sin(5*theta))\n",
    "\n",
    "plt.figure(figsize=(10, 8))\n",
    "ax = plt.subplot(111, projection='polar')\n",
    "ax.plot(theta, r, 'r-', linewidth=2)\n",
    "ax.set_rticks([0.5, 1])\n",
    "ax.set_rlabel_position(0)\n",
    "ax.grid(True)\n",
    "plt.title('Polar Plot', fontsize=16)\n",
    "plt.show()\n",
    "\n",
    "# Radar chart (Spider plot)\n",
    "categories = ['Category A', 'Category B', 'Category C', 'Category D', 'Category E', 'Category F']\n",
    "values = [4, 3, 5, 2, 4, 5]\n",
    "\n",
    "# Number of categories\n",
    "N = len(categories)\n",
    "\n",
    "# Create angles for each category (divide the plot into equal parts)\n",
    "angles = [n / float(N) * 2 * np.pi for n in range(N)]\n",
    "angles += angles[:1]  # Close the loop\n",
    "\n",
    "# Create values for each category (and repeat the first value to close the loop)\n",
    "values += values[:1]\n",
    "\n",
    "# Create the plot\n",
    "plt.figure(figsize=(10, 8))\n",
    "ax = plt.subplot(111, polar=True)\n",
    "\n",
    "# Draw one axis per category and add labels\n",
    "plt.xticks(angles[:-1], categories, fontsize=12)\n",
    "\n",
    "# Draw the y-axis labels (0-5)\n",
    "ax.set_rlabel_position(0)\n",
    "plt.yticks([1, 2, 3, 4, 5], ['1', '2', '3', '4', '5'], fontsize=10)\n",
    "plt.ylim(0, 5)\n",
    "\n",
    "# Plot the data\n",
    "ax.plot(angles, values, 'o-', linewidth=2)\n",
    "ax.fill(angles, values, alpha=0.25)\n",
    "\n",
    "plt.title('Radar Chart', fontsize=16)\n",
    "plt.show()\n",
    "\n",
    "# Stem plot\n",
    "x = np.linspace(0, 2*np.pi, 20)\n",
    "y = np.sin(x)\n",
    "\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.stem(x, y, 'b-', 'bo', 'r-', basefmt='k-')\n",
    "plt.title('Stem Plot', fontsize=16)\n",
    "plt.xlabel('X', fontsize=14)\n",
    "plt.ylabel('sin(X)', fontsize=14)\n",
    "plt.grid(True)\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ## 3. Advanced Matplotlib Techniques\n",
    "\n",
    "# ### 3.1 Multiple Axes and Insets\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "711fef57",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate some data\n",
    "x = np.linspace(0, 10, 100)\n",
    "y1 = np.sin(x)\n",
    "y2 = 100 * np.cos(x)\n",
    "\n",
    "# Create a figure with two y-axes\n",
    "fig, ax1 = plt.subplots(figsize=(12, 6))\n",
    "\n",
    "# Plot on the first y-axis\n",
    "ax1.plot(x, y1, 'b-', linewidth=2, label='sin(x)')\n",
    "ax1.set_xlabel('x', fontsize=14)\n",
    "ax1.set_ylabel('sin(x)', color='blue', fontsize=14)\n",
    "ax1.tick_params(axis='y', labelcolor='blue')\n",
    "ax1.set_ylim(-1.5, 1.5)\n",
    "\n",
    "# Create a second y-axis that shares the same x-axis\n",
    "ax2 = ax1.twinx()\n",
    "ax2.plot(x, y2, 'r-', linewidth=2, label='100*cos(x)')\n",
    "ax2.set_ylabel('100*cos(x)', color='red', fontsize=14)\n",
    "ax2.tick_params(axis='y', labelcolor='red')\n",
    "ax2.set_ylim(-150, 150)\n",
    "\n",
    "# Add a title\n",
    "plt.title('Two Y-Axes Plot', fontsize=16)\n",
    "\n",
    "# Add legends\n",
    "lines1, labels1 = ax1.get_legend_handles_labels()\n",
    "lines2, labels2 = ax2.get_legend_handles_labels()\n",
    "ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper right', fontsize=12)\n",
    "\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Inset plots\n",
    "fig, ax = plt.subplots(figsize=(12, 8))\n",
    "\n",
    "# Main plot\n",
    "ax.plot(x, np.sin(x), 'b-', linewidth=2)\n",
    "ax.set_title('Main Plot with Inset', fontsize=16)\n",
    "ax.set_xlabel('x', fontsize=14)\n",
    "ax.set_ylabel('sin(x)', fontsize=14)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "# Create an inset\n",
    "from mpl_toolkits.axes_grid1.inset_locator import inset_axes, mark_inset\n",
    "\n",
    "# Create the inset axes\n",
    "axins = inset_axes(ax, width=\"40%\", height=\"30%\", loc='lower left',\n",
    "                   bbox_to_anchor=(0.2, 0.2, 0.5, 0.5), bbox_transform=ax.transAxes)\n",
    "\n",
    "# Plot on the inset\n",
    "axins.plot(x, np.sin(x), 'r-', linewidth=2)\n",
    "\n",
    "# Set the limits for the inset\n",
    "x1, x2, y1, y2 = 4, 6, -1, 1\n",
    "axins.set_xlim(x1, x2)\n",
    "axins.set_ylim(y1, y2)\n",
    "axins.grid(True, alpha=0.3)\n",
    "\n",
    "# Draw connecting lines between the inset and the main plot\n",
    "mark_inset(ax, axins, loc1=2, loc2=4, fc=\"none\", ec=\"0.5\")\n",
    "\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 3.2 Custom Colormaps and Color Bars\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f39ccf3",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Generate some data\n",
    "x = np.linspace(-5, 5, 100)\n",
    "y = np.linspace(-5, 5, 100)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "Z = np.sin(np.sqrt(X**2 + Y**2))\n",
    "\n",
    "# Using built-in colormaps\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Create a grid of subplots\n",
    "colormaps = ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'RdBu', 'jet']\n",
    "for i, cmap_name in enumerate(colormaps):\n",
    "    plt.subplot(2, 4, i+1)\n",
    "    plt.contourf(X, Y, Z, 20, cmap=cmap_name)\n",
    "    plt.colorbar(label='Z Value')\n",
    "    plt.title(f'Colormap: {cmap_name}', fontsize=12)\n",
    "    plt.xticks([])\n",
    "    plt.yticks([])\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Creating a custom colormap\n",
    "from matplotlib.colors import LinearSegmentedColormap\n",
    "\n",
    "# Define colors for the custom colormap\n",
    "colors = [(0, 'darkblue'), (0.25, 'blue'), (0.5, 'white'), (0.75, 'red'), (1, 'darkred')]\n",
    "cmap_name = 'BlueWhiteRed'\n",
    "cm = LinearSegmentedColormap.from_list(cmap_name, colors, N=100)\n",
    "\n",
    "# Use the custom colormap\n",
    "plt.figure(figsize=(12, 8))\n",
    "contourf = plt.contourf(X, Y, Z, 20, cmap=cm)\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Custom Colormap', fontsize=16)\n",
    "plt.xlabel('X', fontsize=14)\n",
    "plt.ylabel('Y', fontsize=14)\n",
    "plt.show()\n",
    "\n",
    "# Discrete colormap\n",
    "plt.figure(figsize=(12, 8))\n",
    "levels = np.linspace(-1, 1, 11)  # 10 discrete levels\n",
    "contourf = plt.contourf(X, Y, Z, levels=levels, cmap='RdBu')\n",
    "plt.colorbar(contourf, label='Z Value', ticks=levels)\n",
    "plt.title('Discrete Colormap with 10 Levels', fontsize=16)\n",
    "plt.xlabel('X', fontsize=14)\n",
    "plt.ylabel('Y', fontsize=14)\n",
    "plt.show()\n",
    "\n",
    "# Custom colorbar with nonlinear scaling\n",
    "from matplotlib.colors import LogNorm, PowerNorm, SymLogNorm\n",
    "\n",
    "# Generate data with a large dynamic range\n",
    "Z_pos = np.abs(Z) + 0.1  # Make all values positive and avoid zeros\n",
    "\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Linear scale (default)\n",
    "plt.subplot(2, 2, 1)\n",
    "contourf = plt.contourf(X, Y, Z_pos, 20, cmap='viridis')\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Linear Scale', fontsize=14)\n",
    "plt.xlabel('X', fontsize=12)\n",
    "plt.ylabel('Y', fontsize=12)\n",
    "\n",
    "# Log scale\n",
    "plt.subplot(2, 2, 2)\n",
    "contourf = plt.contourf(X, Y, Z_pos, 20, cmap='viridis', norm=LogNorm())\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Log Scale', fontsize=14)\n",
    "plt.xlabel('X', fontsize=12)\n",
    "plt.ylabel('Y', fontsize=12)\n",
    "\n",
    "# Power scale (square root)\n",
    "plt.subplot(2, 2, 3)\n",
    "contourf = plt.contourf(X, Y, Z_pos, 20, cmap='viridis', norm=PowerNorm(gamma=0.5))\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Power Scale (gamma=0.5)', fontsize=14)\n",
    "plt.xlabel('X', fontsize=12)\n",
    "plt.ylabel('Y', fontsize=12)\n",
    "\n",
    "# Symmetric log scale (for data with both positive and negative values)\n",
    "plt.subplot(2, 2, 4)\n",
    "contourf = plt.contourf(X, Y, Z, 20, cmap='RdBu', norm=SymLogNorm(linthresh=0.1))\n",
    "plt.colorbar(contourf, label='Z Value')\n",
    "plt.title('Symmetric Log Scale', fontsize=14)\n",
    "plt.xlabel('X', fontsize=12)\n",
    "plt.ylabel('Y', fontsize=12)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 3.3 Animations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c73d5502",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import animation tools\n",
    "from matplotlib.animation import FuncAnimation\n",
    "\n",
    "# Create a figure and axis\n",
    "fig, ax = plt.subplots(figsize=(10, 6))\n",
    "\n",
    "# Initialize an empty line\n",
    "line, = ax.plot([], [], 'b-', linewidth=2)\n",
    "\n",
    "# Set up the plot\n",
    "ax.set_xlim(0, 2*np.pi)\n",
    "ax.set_ylim(-1.1, 1.1)\n",
    "ax.set_xlabel('x', fontsize=14)\n",
    "ax.set_ylabel('sin(x - phase)', fontsize=14)\n",
    "ax.set_title('Sine Wave Animation', fontsize=16)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "# Initialization function\n",
    "def init():\n",
    "    line.set_data([], [])\n",
    "    return line,\n",
    "\n",
    "# Animation function\n",
    "def animate(i):\n",
    "    x = np.linspace(0, 2*np.pi, 100)\n",
    "    y = np.sin(x - 0.1*i)  # Phase shift\n",
    "    line.set_data(x, y)\n",
    "    ax.set_title(f'Sine Wave Animation (Frame {i})', fontsize=16)\n",
    "    return line,\n",
    "\n",
    "# Create the animation\n",
    "# anim = FuncAnimation(fig, animate, init_func=init, frames=100, interval=50, blit=True)\n",
    "\n",
    "# To save the animation (uncomment to use)\n",
    "# anim.save('sine_wave.gif', writer='pillow', fps=20)\n",
    "\n",
    "# Display a static frame for demonstration\n",
    "animate(10)\n",
    "plt.show()\n",
    "\n",
    "# Example of a more complex animation: 3D surface that evolves over time\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "# Create figure and 3D axis\n",
    "fig = plt.figure(figsize=(10, 8))\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "\n",
    "# Set up the grid\n",
    "x = np.linspace(-5, 5, 50)\n",
    "y = np.linspace(-5, 5, 50)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "# Function to update the plot for each frame\n",
    "def update_plot(frame):\n",
    "    ax.clear()\n",
    "    \n",
    "    # Calculate Z with time dependence\n",
    "    Z = np.sin(np.sqrt(X**2 + Y**2) - 0.1*frame)\n",
    "    \n",
    "    # Plot the surface\n",
    "    surf = ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none', alpha=0.8)\n",
    "    \n",
    "    # Set labels and title\n",
    "    ax.set_xlabel('X', fontsize=12)\n",
    "    ax.set_ylabel('Y', fontsize=12)\n",
    "    ax.set_zlabel('Z', fontsize=12)\n",
    "    ax.set_title(f'Evolving Surface (Frame {frame})', fontsize=14)\n",
    "    \n",
    "    return surf,\n",
    "\n",
    "# Create the animation\n",
    "# anim = FuncAnimation(fig, update_plot, frames=100, interval=50, blit=False)\n",
    "\n",
    "# To save the animation (uncomment to use)\n",
    "# anim.save('surface_evolution.gif', writer='pillow', fps=20)\n",
    "\n",
    "# Display a static frame for demonstration\n",
    "update_plot(10)\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 3.4 Interactive Plots\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "98df2d93",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Note: Interactive plots require a backend that supports interactivity.\n",
    "# In a Jupyter notebook, you might use %matplotlib notebook or %matplotlib widget.\n",
    "# Here we'll show the code but the interactivity won't be visible in a static document.\n",
    "\n",
    "# Import necessary libraries\n",
    "from matplotlib.widgets import Slider, Button, RadioButtons, CheckButtons\n",
    "\n",
    "# Create a figure and axis\n",
    "fig, ax = plt.subplots(figsize=(10, 8))\n",
    "plt.subplots_adjust(left=0.25, bottom=0.25)\n",
    "\n",
    "# Generate initial data\n",
    "t = np.linspace(0, 1, 1000)\n",
    "a0 = 5\n",
    "f0 = 3\n",
    "s = a0 * np.sin(2 * np.pi * f0 * t)\n",
    "l, = plt.plot(t, s, lw=2)\n",
    "\n",
    "# Set up the plot\n",
    "ax.set_xlabel('Time [s]', fontsize=12)\n",
    "ax.set_ylabel('Amplitude', fontsize=12)\n",
    "ax.set_title('Interactive Sine Wave', fontsize=14)\n",
    "ax.grid(True, alpha=0.3)\n",
    "\n",
    "# Add sliders for amplitude and frequency\n",
    "ax_amp = plt.axes([0.25, 0.1, 0.65, 0.03])\n",
    "ax_freq = plt.axes([0.25, 0.15, 0.65, 0.03])\n",
    "\n",
    "s_amp = Slider(ax_amp, 'Amplitude', 0.1, 10.0, valinit=a0)\n",
    "s_freq = Slider(ax_freq, 'Frequency', 0.1, 10.0, valinit=f0)\n",
    "\n",
    "# Function to update the plot when sliders change\n",
    "def update(val):\n",
    "    amp = s_amp.val\n",
    "    freq = s_freq.val\n",
    "    l.set_ydata(amp * np.sin(2 * np.pi * freq * t))\n",
    "    fig.canvas.draw_idle()\n",
    "\n",
    "# Connect the sliders to the update function\n",
    "s_amp.on_changed(update)\n",
    "s_freq.on_changed(update)\n",
    "\n",
    "# Add a reset button\n",
    "ax_reset = plt.axes([0.8, 0.025, 0.1, 0.04])\n",
    "button = Button(ax_reset, 'Reset', color='lightgoldenrodyellow', hovercolor='0.975')\n",
    "\n",
    "def reset(event):\n",
    "    s_amp.reset()\n",
    "    s_freq.reset()\n",
    "button.on_clicked(reset)\n",
    "\n",
    "# Add radio buttons to select waveform\n",
    "ax_radio = plt.axes([0.025, 0.5, 0.15, 0.15])\n",
    "radio = RadioButtons(ax_radio, ('Sine', 'Square', 'Sawtooth'))\n",
    "\n",
    "def wave_type(label):\n",
    "    if label == 'Sine':\n",
    "        l.set_ydata(s_amp.val * np.sin(2 * np.pi * s_freq.val * t))\n",
    "    elif label == 'Square':\n",
    "        l.set_ydata(s_amp.val * np.sign(np.sin(2 * np.pi * s_freq.val * t)))\n",
    "    elif label == 'Sawtooth':\n",
    "        l.set_ydata(s_amp.val * (2 * (s_freq.val * t - np.floor(s_freq.val * t + 0.5))))\n",
    "    fig.canvas.draw_idle()\n",
    "radio.on_clicked(wave_type)\n",
    "\n",
    "# Add checkboxes for grid and axis visibility\n",
    "ax_check = plt.axes([0.025, 0.3, 0.15, 0.1])\n",
    "check = CheckButtons(ax_check, ('Grid', 'X Label', 'Y Label'), (True, True, True))\n",
    "\n",
    "def func(label):\n",
    "    if label == 'Grid':\n",
    "        ax.grid(not ax.get_xgrid()[0].get_visible())\n",
    "    elif label == 'X Label':\n",
    "        ax.xaxis.label.set_visible(not ax.xaxis.label.get_visible())\n",
    "    elif label == 'Y Label':\n",
    "        ax.yaxis.label.set_visible(not ax.yaxis.label.get_visible())\n",
    "    fig.canvas.draw_idle()\n",
    "check.on_clicked(func)\n",
    "\n",
    "plt.show()\n",
    "\n",
    "# Note: The interactive elements won't work in a static document.\n",
    "# In a Jupyter notebook with the right backend, you would see interactive controls.\n",
    "\n",
    "\n",
    "# ## 4. Real-world Applications of Matplotlib in Machine Learning\n",
    "\n",
    "# ### 4.1 Visualizing Dataset Distributions\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b26fe56a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.datasets import load_iris, load_wine, load_breast_cancer\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "# Set the style\n",
    "plt.style.use('ggplot')\n",
    "\n",
    "# Load datasets\n",
    "iris = load_iris()\n",
    "wine = load_wine()\n",
    "cancer = load_breast_cancer()\n",
    "\n",
    "# Create DataFrames\n",
    "iris_df = pd.DataFrame(iris.data, columns=iris.feature_names)\n",
    "iris_df['target'] = iris.target\n",
    "iris_df['species'] = iris_df['target'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})\n",
    "\n",
    "wine_df = pd.DataFrame(wine.data, columns=wine.feature_names)\n",
    "wine_df['target'] = wine.target\n",
    "\n",
    "cancer_df = pd.DataFrame(cancer.data, columns=cancer.feature_names)\n",
    "cancer_df['target'] = cancer.target\n",
    "cancer_df['diagnosis'] = cancer_df['target'].map({0: 'malignant', 1: 'benign'})\n",
    "\n",
    "# Visualizing Iris dataset\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Histogram of sepal length by species\n",
    "plt.subplot(2, 2, 1)\n",
    "for species, color in zip(['setosa', 'versicolor', 'virginica'], ['blue', 'green', 'red']):\n",
    "    subset = iris_df[iris_df['species'] == species]\n",
    "    plt.hist(subset['sepal length (cm)'], bins=10, alpha=0.5, color=color, label=species)\n",
    "plt.title('Sepal Length Distribution by Species', fontsize=14)\n",
    "plt.xlabel('Sepal Length (cm)', fontsize=12)\n",
    "plt.ylabel('Frequency', fontsize=12)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Scatter plot of sepal length vs sepal width\n",
    "plt.subplot(2, 2, 2)\n",
    "for species, color in zip(['setosa', 'versicolor', 'virginica'], ['blue', 'green', 'red']):\n",
    "    subset = iris_df[iris_df['species'] == species]\n",
    "    plt.scatter(subset['sepal length (cm)'], subset['sepal width (cm)'], \n",
    "               c=color, label=species, alpha=0.7, edgecolors='w', s=50)\n",
    "plt.title('Sepal Length vs Sepal Width', fontsize=14)\n",
    "plt.xlabel('Sepal Length (cm)', fontsize=12)\n",
    "plt.ylabel('Sepal Width (cm)', fontsize=12)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Scatter plot of petal length vs petal width\n",
    "plt.subplot(2, 2, 3)\n",
    "for species, color in zip(['setosa', 'versicolor', 'virginica'], ['blue', 'green', 'red']):\n",
    "    subset = iris_df[iris_df['species'] == species]\n",
    "    plt.scatter(subset['petal length (cm)'], subset['petal width (cm)'], \n",
    "               c=color, label=species, alpha=0.7, edgecolors='w', s=50)\n",
    "plt.title('Petal Length vs Petal Width', fontsize=14)\n",
    "plt.xlabel('Petal Length (cm)', fontsize=12)\n",
    "plt.ylabel('Petal Width (cm)', fontsize=12)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Box plot of all features\n",
    "plt.subplot(2, 2, 4)\n",
    "# Melt the DataFrame to long format for easier plotting\n",
    "iris_melt = pd.melt(iris_df, id_vars=['species'], \n",
    "                    value_vars=['sepal length (cm)', 'sepal width (cm)', \n",
    "                               'petal length (cm)', 'petal width (cm)'],\n",
    "                    var_name='feature', value_name='value')\n",
    "# Create box plot\n",
    "for i, species in enumerate(['setosa', 'versicolor', 'virginica']):\n",
    "    subset = iris_melt[iris_melt['species'] == species]\n",
    "    positions = np.array([0, 1, 2, 3]) + 0.2*i - 0.2\n",
    "    plt.boxplot([subset[subset['feature'] == f]['value'] for f in \n",
    "                ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']],\n",
    "                positions=positions, widths=0.15, patch_artist=True,\n",
    "                boxprops=dict(facecolor=['blue', 'green', 'red'][i], alpha=0.5),\n",
    "                medianprops=dict(color='black'), \n",
    "                flierprops=dict(markerfacecolor=['blue', 'green', 'red'][i], alpha=0.5))\n",
    "\n",
    "plt.xticks([0, 1, 2, 3], ['Sepal Length', 'Sepal Width', 'Petal Length', 'Petal Width'], rotation=45)\n",
    "plt.title('Feature Distributions by Species', fontsize=14)\n",
    "plt.ylabel('Value (cm)', fontsize=12)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Visualizing Wine dataset features\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Select a subset of features for visualization\n",
    "selected_features = ['alcohol', 'malic_acid', 'ash', 'alcalinity_of_ash', 'magnesium']\n",
    "\n",
    "# Parallel coordinates plot\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "scaler = MinMaxScaler()\n",
    "wine_scaled = scaler.fit_transform(wine_df[selected_features])\n",
    "wine_scaled_df = pd.DataFrame(wine_scaled, columns=selected_features)\n",
    "wine_scaled_df['target'] = wine_df['target']\n",
    "\n",
    "plt.subplot(2, 2, 1)\n",
    "pd.plotting.parallel_coordinates(wine_scaled_df, 'target', colormap=plt.cm.Set2)\n",
    "plt.title('Parallel Coordinates Plot of Wine Features', fontsize=14)\n",
    "plt.xticks(rotation=45)\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Andrews curves\n",
    "plt.subplot(2, 2, 2)\n",
    "pd.plotting.andrews_curves(wine_scaled_df, 'target', colormap=plt.cm.Set2)\n",
    "plt.title('Andrews Curves of Wine Features', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Correlation heatmap\n",
    "plt.subplot(2, 2, 3)\n",
    "correlation = wine_df[selected_features].corr()\n",
    "im = plt.imshow(correlation, cmap='coolwarm')\n",
    "plt.colorbar(im, label='Correlation Coefficient')\n",
    "plt.title('Correlation Heatmap of Wine Features', fontsize=14)\n",
    "plt.xticks(np.arange(len(selected_features)), selected_features, rotation=45, ha='right')\n",
    "plt.yticks(np.arange(len(selected_features)), selected_features)\n",
    "\n",
    "# Add text annotations\n",
    "for i in range(len(selected_features)):\n",
    "    for j in range(len(selected_features)):\n",
    "        plt.text(j, i, f'{correlation.iloc[i, j]:.2f}', \n",
    "                 ha='center', va='center', \n",
    "                 color='white' if abs(correlation.iloc[i, j]) > 0.7 else 'black',\n",
    "                 fontsize=9)\n",
    "\n",
    "# Scatter matrix\n",
    "plt.subplot(2, 2, 4)\n",
    "from pandas.plotting import scatter_matrix\n",
    "scatter_matrix(wine_df[selected_features[:3]], alpha=0.7, figsize=(6, 6), diagonal='kde')\n",
    "plt.suptitle('Scatter Matrix of Wine Features', fontsize=14)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.subplots_adjust(top=0.9)\n",
    "plt.show()\n",
    "\n",
    "# Visualizing Breast Cancer dataset\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Select a subset of features for visualization\n",
    "selected_features = ['mean radius', 'mean texture', 'mean perimeter', 'mean area', 'mean smoothness']\n",
    "\n",
    "# Box plot by diagnosis\n",
    "plt.subplot(2, 2, 1)\n",
    "cancer_melt = pd.melt(cancer_df, id_vars=['diagnosis'], \n",
    "                     value_vars=selected_features,\n",
    "                     var_name='feature', value_name='value')\n",
    "\n",
    "# Create separate box plots for malignant and benign\n",
    "for i, diagnosis in enumerate(['malignant', 'benign']):\n",
    "    subset = cancer_melt[cancer_melt['diagnosis'] == diagnosis]\n",
    "    positions = np.array([0, 1, 2, 3, 4]) + 0.2*i - 0.2\n",
    "    plt.boxplot([subset[subset['feature'] == f]['value'] for f in selected_features],\n",
    "                positions=positions, widths=0.15, patch_artist=True,\n",
    "                boxprops=dict(facecolor=['red', 'green'][i], alpha=0.5),\n",
    "                medianprops=dict(color='black'), \n",
    "                flierprops=dict(markerfacecolor=['red', 'green'][i], alpha=0.5))\n",
    "\n",
    "plt.xticks([0, 1, 2, 3, 4], selected_features, rotation=45)\n",
    "plt.title('Feature Distributions by Diagnosis', fontsize=14)\n",
    "plt.ylabel('Value', fontsize=12)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "\n",
    "# Violin plots\n",
    "plt.subplot(2, 2, 2)\n",
    "for i, feature in enumerate(selected_features[:3]):\n",
    "    plt.violinplot([cancer_df[cancer_df['diagnosis'] == 'malignant'][feature],\n",
    "                   cancer_df[cancer_df['diagnosis'] == 'benign'][feature]],\n",
    "                  positions=[i*2, i*2+1], showmeans=True, showmedians=True)\n",
    "    \n",
    "plt.xticks([0, 1, 2, 3, 4, 5], ['M', 'B', 'M', 'B', 'M', 'B'])\n",
    "plt.title('Violin Plots of Features by Diagnosis', fontsize=14)\n",
    "plt.xlabel('Diagnosis (M=Malignant, B=Benign)', fontsize=12)\n",
    "plt.ylabel('Value', fontsize=12)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "\n",
    "# Histogram of mean radius by diagnosis\n",
    "plt.subplot(2, 2, 3)\n",
    "for diagnosis, color in zip(['malignant', 'benign'], ['red', 'green']):\n",
    "    subset = cancer_df[cancer_df['diagnosis'] == diagnosis]\n",
    "    plt.hist(subset['mean radius'], bins=15, alpha=0.5, color=color, label=diagnosis)\n",
    "plt.title('Mean Radius Distribution by Diagnosis', fontsize=14)\n",
    "plt.xlabel('Mean Radius', fontsize=12)\n",
    "plt.ylabel('Frequency', fontsize=12)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Scatter plot with multiple features\n",
    "plt.subplot(2, 2, 4)\n",
    "for diagnosis, color in zip(['malignant', 'benign'], ['red', 'green']):\n",
    "    subset = cancer_df[cancer_df['diagnosis'] == diagnosis]\n",
    "    plt.scatter(subset['mean radius'], subset['mean texture'], \n",
    "               c=color, s=subset['mean area']/10, label=diagnosis, alpha=0.7, edgecolors='w')\n",
    "plt.title('Radius vs Texture (Size = Area)', fontsize=14)\n",
    "plt.xlabel('Mean Radius', fontsize=12)\n",
    "plt.ylabel('Mean Texture', fontsize=12)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 4.2 Learning Curves and Model Evaluation\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b54f2731",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from sklearn.datasets import load_digits\n",
    "from sklearn.model_selection import learning_curve, validation_curve, cross_val_score, KFold\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.metrics import confusion_matrix, roc_curve, precision_recall_curve, auc\n",
    "\n",
    "# Load the digits dataset\n",
    "digits = load_digits()\n",
    "X, y = digits.data, digits.target\n",
    "\n",
    "# Plot learning curves\n",
    "def plot_learning_curve(estimator, title, X, y, ylim=None, cv=None,\n",
    "                        n_jobs=None, train_sizes=np.linspace(.1, 1.0, 5)):\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    plt.title(title, fontsize=16)\n",
    "    if ylim is not None:\n",
    "        plt.ylim(*ylim)\n",
    "    plt.xlabel(\"Training examples\", fontsize=14)\n",
    "    plt.ylabel(\"Score\", fontsize=14)\n",
    "    \n",
    "    train_sizes, train_scores, test_scores = learning_curve(\n",
    "        estimator, X, y, cv=cv, n_jobs=n_jobs, train_sizes=train_sizes)\n",
    "    \n",
    "    train_scores_mean = np.mean(train_scores, axis=1)\n",
    "    train_scores_std = np.std(train_scores, axis=1)\n",
    "    test_scores_mean = np.mean(test_scores, axis=1)\n",
    "    test_scores_std = np.std(test_scores, axis=1)\n",
    "    \n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.fill_between(train_sizes, train_scores_mean - train_scores_std,\n",
    "                     train_scores_mean + train_scores_std, alpha=0.1, color=\"r\")\n",
    "    plt.fill_between(train_sizes, test_scores_mean - test_scores_std,\n",
    "                     test_scores_mean + test_scores_std, alpha=0.1, color=\"g\")\n",
    "    plt.plot(train_sizes, train_scores_mean, 'o-', color=\"r\", label=\"Training score\")\n",
    "    plt.plot(train_sizes, test_scores_mean, 'o-', color=\"g\", label=\"Cross-validation score\")\n",
    "    \n",
    "    plt.legend(loc=\"best\", fontsize=12)\n",
    "    return plt\n",
    "\n",
    "# Plot learning curves for different classifiers\n",
    "plot_learning_curve(\n",
    "    SVC(gamma=0.001), \"Learning Curve (SVM, RBF kernel, $\\gamma=0.001$)\",\n",
    "    X, y, cv=5, n_jobs=-1)\n",
    "plt.show()\n",
    "\n",
    "plot_learning_curve(\n",
    "    DecisionTreeClassifier(max_depth=5), \"Learning Curve (Decision Tree, max_depth=5)\",\n",
    "    X, y, cv=5, n_jobs=-1)\n",
    "plt.show()\n",
    "\n",
    "# Plot validation curve\n",
    "def plot_validation_curve(estimator, title, X, y, param_name, param_range, cv=None, n_jobs=None):\n",
    "    plt.figure(figsize=(10, 6))\n",
    "    plt.title(title, fontsize=16)\n",
    "    plt.xlabel(param_name, fontsize=14)\n",
    "    plt.ylabel(\"Score\", fontsize=14)\n",
    "    \n",
    "    train_scores, test_scores = validation_curve(\n",
    "        estimator, X, y, param_name=param_name, param_range=param_range,\n",
    "        cv=cv, n_jobs=n_jobs)\n",
    "    \n",
    "    train_scores_mean = np.mean(train_scores, axis=1)\n",
    "    train_scores_std = np.std(train_scores, axis=1)\n",
    "    test_scores_mean = np.mean(test_scores, axis=1)\n",
    "    test_scores_std = np.std(test_scores, axis=1)\n",
    "    \n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.fill_between(param_range, train_scores_mean - train_scores_std,\n",
    "                     train_scores_mean + train_scores_std, alpha=0.1, color=\"r\")\n",
    "    plt.fill_between(param_range, test_scores_mean - test_scores_std,\n",
    "                     test_scores_mean + test_scores_std, alpha=0.1, color=\"g\")\n",
    "    plt.plot(param_range, train_scores_mean, 'o-', color=\"r\", label=\"Training score\")\n",
    "    plt.plot(param_range, test_scores_mean, 'o-', color=\"g\", label=\"Cross-validation score\")\n",
    "    \n",
    "    plt.legend(loc=\"best\", fontsize=12)\n",
    "    return plt\n",
    "\n",
    "# Plot validation curves for different parameters\n",
    "param_range = np.logspace(-3, 3, 10)\n",
    "plot_validation_curve(\n",
    "    SVC(), \"Validation Curve (SVM, RBF kernel)\", X, y, \"gamma\", param_range, cv=5, n_jobs=-1)\n",
    "plt.xscale(\"log\")\n",
    "plt.show()\n",
    "\n",
    "param_range = np.arange(1, 20, 2)\n",
    "plot_validation_curve(\n",
    "    KNeighborsClassifier(), \"Validation Curve (KNN)\", X, y, \"n_neighbors\", param_range, cv=5, n_jobs=-1)\n",
    "plt.show()\n",
    "\n",
    "# Cross-validation scores comparison\n",
    "classifiers = [\n",
    "    SVC(gamma=0.001),\n",
    "    DecisionTreeClassifier(max_depth=5),\n",
    "    RandomForestClassifier(n_estimators=100, max_depth=5, random_state=42),\n",
    "    KNeighborsClassifier(n_neighbors=5)\n",
    "]\n",
    "\n",
    "cv = KFold(n_splits=5, shuffle=True, random_state=42)\n",
    "cv_scores = []\n",
    "\n",
    "for classifier in classifiers:\n",
    "    scores = cross_val_score(classifier, X, y, cv=cv, scoring='accuracy')\n",
    "    cv_scores.append(scores)\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.boxplot(cv_scores, labels=['SVM', 'Decision Tree', 'Random Forest', 'KNN'])\n",
    "plt.title('Cross-validation Accuracy Comparison', fontsize=16)\n",
    "plt.xlabel('Classifier', fontsize=14)\n",
    "plt.ylabel('Accuracy', fontsize=14)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Confusion Matrix Visualization\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import confusion_matrix\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n",
    "\n",
    "# Train a classifier\n",
    "clf = RandomForestClassifier(n_estimators=100, random_state=42)\n",
    "clf.fit(X_train, y_train)\n",
    "y_pred = clf.predict(X_test)\n",
    "\n",
    "# Compute confusion matrix\n",
    "cm = confusion_matrix(y_test, y_pred)\n",
    "\n",
    "plt.figure(figsize=(10, 8))\n",
    "plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)\n",
    "plt.title('Confusion Matrix', fontsize=16)\n",
    "plt.colorbar()\n",
    "\n",
    "# Add labels\n",
    "classes = np.unique(y)\n",
    "tick_marks = np.arange(len(classes))\n",
    "plt.xticks(tick_marks, classes, fontsize=12)\n",
    "plt.yticks(tick_marks, classes, fontsize=12)\n",
    "plt.xlabel('Predicted label', fontsize=14)\n",
    "plt.ylabel('True label', fontsize=14)\n",
    "\n",
    "# Add text annotations\n",
    "thresh = cm.max() / 2.\n",
    "for i in range(cm.shape[0]):\n",
    "    for j in range(cm.shape[1]):\n",
    "        plt.text(j, i, format(cm[i, j], 'd'),\n",
    "                 horizontalalignment=\"center\",\n",
    "                 color=\"white\" if cm[i, j] > thresh else \"black\",\n",
    "                 fontsize=12)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# ROC Curve and Precision-Recall Curve\n",
    "# For this example, we'll convert to a binary classification problem\n",
    "# Let's classify digit 1 vs all others\n",
    "y_binary = (y == 1).astype(int)\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y_binary, test_size=0.3, random_state=42)\n",
    "\n",
    "# Train a classifier\n",
    "clf = SVC(gamma=0.001, probability=True)\n",
    "clf.fit(X_train, y_train)\n",
    "y_score = clf.predict_proba(X_test)[:, 1]\n",
    "\n",
    "# Compute ROC curve and ROC area\n",
    "fpr, tpr, _ = roc_curve(y_test, y_score)\n",
    "roc_auc = auc(fpr, tpr)\n",
    "\n",
    "# Compute precision-recall curve\n",
    "precision, recall, _ = precision_recall_curve(y_test, y_score)\n",
    "pr_auc = auc(recall, precision)\n",
    "\n",
    "# Plot ROC curve\n",
    "plt.figure(figsize=(12, 5))\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')\n",
    "plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')\n",
    "plt.xlim([0.0, 1.0])\n",
    "plt.ylim([0.0, 1.05])\n",
    "plt.xlabel('False Positive Rate', fontsize=12)\n",
    "plt.ylabel('True Positive Rate', fontsize=12)\n",
    "plt.title('Receiver Operating Characteristic', fontsize=14)\n",
    "plt.legend(loc=\"lower right\", fontsize=10)\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# Plot precision-recall curve\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.plot(recall, precision, color='darkgreen', lw=2, label=f'PR curve (area = {pr_auc:.2f})')\n",
    "plt.xlabel('Recall', fontsize=12)\n",
    "plt.ylabel('Precision', fontsize=12)\n",
    "plt.title('Precision-Recall Curve', fontsize=14)\n",
    "plt.legend(loc=\"lower left\", fontsize=10)\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 4.3 Feature Importance Visualization\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "26b62515",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.datasets import load_diabetes, load_breast_cancer\n",
    "from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\n",
    "from sklearn.inspection import permutation_importance\n",
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "# Load datasets\n",
    "diabetes = load_diabetes()\n",
    "cancer = load_breast_cancer()\n",
    "\n",
    "# Prepare diabetes dataset\n",
    "X_diabetes, y_diabetes = diabetes.data, diabetes.target\n",
    "feature_names_diabetes = diabetes.feature_names\n",
    "\n",
    "# Train a random forest regressor\n",
    "rf_reg = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "rf_reg.fit(X_diabetes, y_diabetes)\n",
    "\n",
    "# Get feature importances\n",
    "importances = rf_reg.feature_importances_\n",
    "indices = np.argsort(importances)[::-1]\n",
    "\n",
    "# Prepare breast cancer dataset\n",
    "X_cancer, y_cancer = cancer.data, cancer.target\n",
    "feature_names_cancer = cancer.feature_names\n",
    "\n",
    "# Train a random forest classifier\n",
    "rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)\n",
    "rf_clf.fit(X_cancer, y_cancer)\n",
    "\n",
    "# Get feature importances\n",
    "importances_cancer = rf_clf.feature_importances_\n",
    "indices_cancer = np.argsort(importances_cancer)[::-1]\n",
    "\n",
    "# Plot feature importances for diabetes dataset\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.title('Feature Importances (Diabetes Dataset)', fontsize=16)\n",
    "plt.bar(range(X_diabetes.shape[1]), importances[indices], align='center', alpha=0.7)\n",
    "plt.xticks(range(X_diabetes.shape[1]), [feature_names_diabetes[i] for i in indices], rotation=90)\n",
    "plt.xlabel('Features', fontsize=14)\n",
    "plt.ylabel('Importance', fontsize=14)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Plot feature importances for breast cancer dataset (top 15)\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.title('Top 15 Feature Importances (Breast Cancer Dataset)', fontsize=16)\n",
    "plt.bar(range(15), importances_cancer[indices_cancer][:15], align='center', alpha=0.7)\n",
    "plt.xticks(range(15), [feature_names_cancer[i] for i in indices_cancer][:15], rotation=90)\n",
    "plt.xlabel('Features', fontsize=14)\n",
    "plt.ylabel('Importance', fontsize=14)\n",
    "plt.grid(True, axis='y', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Horizontal bar chart for better readability\n",
    "plt.figure(figsize=(12, 10))\n",
    "plt.title('Feature Importances (Breast Cancer Dataset)', fontsize=16)\n",
    "plt.barh(range(15), importances_cancer[indices_cancer][:15], align='center', alpha=0.7)\n",
    "plt.yticks(range(15), [feature_names_cancer[i] for i in indices_cancer][:15])\n",
    "plt.xlabel('Importance', fontsize=14)\n",
    "plt.ylabel('Features', fontsize=14)\n",
    "plt.grid(True, axis='x', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Permutation importance (more robust measure of feature importance)\n",
    "X_train, X_test, y_train, y_test = train_test_split(X_cancer, y_cancer, test_size=0.3, random_state=42)\n",
    "rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)\n",
    "rf_clf.fit(X_train, y_train)\n",
    "\n",
    "# Calculate permutation importance\n",
    "result = permutation_importance(rf_clf, X_test, y_test, n_repeats=10, random_state=42)\n",
    "perm_importances = result.importances_mean\n",
    "perm_indices = np.argsort(perm_importances)[::-1]\n",
    "\n",
    "# Plot permutation importances\n",
    "plt.figure(figsize=(12, 10))\n",
    "plt.title('Permutation Feature Importances (Breast Cancer Dataset)', fontsize=16)\n",
    "plt.barh(range(15), perm_importances[perm_indices][:15], align='center', alpha=0.7)\n",
    "plt.yticks(range(15), [feature_names_cancer[i] for i in perm_indices][:15])\n",
    "plt.xlabel('Importance', fontsize=14)\n",
    "plt.ylabel('Features', fontsize=14)\n",
    "plt.grid(True, axis='x', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Compare feature importance methods\n",
    "plt.figure(figsize=(15, 10))\n",
    "\n",
    "# Select top 10 features for comparison\n",
    "top_indices = indices_cancer[:10]\n",
    "feature_names_top = [feature_names_cancer[i] for i in top_indices]\n",
    "\n",
    "# MDI importance (Mean Decrease in Impurity)\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.title('MDI Feature Importances', fontsize=16)\n",
    "plt.barh(range(10), importances_cancer[top_indices], align='center', alpha=0.7)\n",
    "plt.yticks(range(10), feature_names_top)\n",
    "plt.xlabel('Importance', fontsize=14)\n",
    "plt.ylabel('Features', fontsize=14)\n",
    "plt.grid(True, axis='x', alpha=0.3)\n",
    "\n",
    "# Permutation importance for the same features\n",
    "perm_values = [perm_importances[i] for i in top_indices]\n",
    "plt.subplot(2, 1, 2)\n",
    "plt.title('Permutation Feature Importances', fontsize=16)\n",
    "plt.barh(range(10), perm_values, align='center', alpha=0.7)\n",
    "plt.yticks(range(10), feature_names_top)\n",
    "plt.xlabel('Importance', fontsize=14)\n",
    "plt.ylabel('Features', fontsize=14)\n",
    "plt.grid(True, axis='x', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Feature importance with error bars (standard deviation)\n",
    "plt.figure(figsize=(12, 10))\n",
    "plt.title('Feature Importances with Standard Deviation', fontsize=16)\n",
    "\n",
    "# Sort by permutation importance\n",
    "sorted_idx = perm_indices[:15]\n",
    "y_ticks = np.arange(0, len(sorted_idx))\n",
    "\n",
    "# Plot with error bars\n",
    "plt.barh(y_ticks, perm_importances[sorted_idx], xerr=result.importances_std[sorted_idx], \n",
    "        align='center', alpha=0.7)\n",
    "plt.yticks(y_ticks, [feature_names_cancer[i] for i in sorted_idx])\n",
    "plt.xlabel('Permutation Importance', fontsize=14)\n",
    "plt.grid(True, axis='x', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### 4.4 Decision Boundaries Visualization\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99626e29",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from sklearn.datasets import make_classification, make_moons, make_circles\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.neural_network import MLPClassifier\n",
    "from sklearn.inspection import DecisionBoundaryDisplay\n",
    "\n",
    "# Function to plot decision boundaries\n",
    "def plot_decision_boundaries(X, y, classifiers, classifier_names):\n",
    "    # Standardize features\n",
    "    X = StandardScaler().fit_transform(X)\n",
    "    \n",
    "    # Split data into training and test sets\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n",
    "    \n",
    "    # Create a mesh grid\n",
    "    h = 0.02  # step size in the mesh\n",
    "    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\n",
    "    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\n",
    "    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))\n",
    "    \n",
    "    # Create figure\n",
    "    plt.figure(figsize=(15, 10))\n",
    "    \n",
    "    # Plot decision boundaries for each classifier\n",
    "    for i, (clf, name) in enumerate(zip(classifiers, classifier_names)):\n",
    "        # Train classifier\n",
    "        clf.fit(X_train, y_train)\n",
    "        \n",
    "        # Plot decision boundary\n",
    "        plt.subplot(2, 3, i + 1)\n",
    "        \n",
    "        # Use DecisionBoundaryDisplay for cleaner code\n",
    "        DecisionBoundaryDisplay.from_estimator(\n",
    "            clf, X, cmap=plt.cm.RdBu, alpha=0.8, response_method=\"predict\",\n",
    "            xlabel=\"Feature 1\", ylabel=\"Feature 2\", ax=plt.gca()\n",
    "        )\n",
    "        \n",
    "        # Plot training and test points\n",
    "        plt.scatter(X_train[:, 0], X_train[:, 1], c=y_train, edgecolors='k', \n",
    "                   cmap=plt.cm.RdBu, alpha=0.6)\n",
    "        plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test, edgecolors='k', \n",
    "                   cmap=plt.cm.RdBu, alpha=0.6, marker='^')\n",
    "        \n",
    "        # Calculate and display accuracy\n",
    "        accuracy = clf.score(X_test, y_test)\n",
    "        plt.title(f'{name} (Accuracy: {accuracy:.2f})', fontsize=14)\n",
    "        plt.xlabel('Feature 1', fontsize=12)\n",
    "        plt.ylabel('Feature 2', fontsize=12)\n",
    "        plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "# Create classifiers\n",
    "classifiers = [\n",
    "    SVC(kernel='linear'),\n",
    "    SVC(kernel='rbf', gamma=0.5),\n",
    "    DecisionTreeClassifier(max_depth=5),\n",
    "    RandomForestClassifier(n_estimators=100, max_depth=5),\n",
    "    KNeighborsClassifier(n_neighbors=5),\n",
    "    MLPClassifier(hidden_layer_sizes=(100,), max_iter=1000)\n",
    "]\n",
    "\n",
    "classifier_names = [\n",
    "    'Linear SVM',\n",
    "    'RBF SVM',\n",
    "    'Decision Tree',\n",
    "    'Random Forest',\n",
    "    'K-Nearest Neighbors',\n",
    "    'Neural Network'\n",
    "]\n",
    "\n",
    "# Generate linearly separable data\n",
    "X, y = make_classification(n_samples=200, n_features=2, n_redundant=0, n_informative=2,\n",
    "                          random_state=1, n_clusters_per_class=1)\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k', cmap=plt.cm.RdBu)\n",
    "plt.title('Linearly Separable Data', fontsize=16)\n",
    "plt.xlabel('Feature 1', fontsize=14)\n",
    "plt.ylabel('Feature 2', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Plot decision boundaries for linearly separable data\n",
    "plot_decision_boundaries(X, y, classifiers, classifier_names)\n",
    "\n",
    "# Generate moon-shaped data\n",
    "X, y = make_moons(n_samples=200, noise=0.3, random_state=42)\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k', cmap=plt.cm.RdBu)\n",
    "plt.title('Moon-Shaped Data', fontsize=16)\n",
    "plt.xlabel('Feature 1', fontsize=14)\n",
    "plt.ylabel('Feature 2', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Plot decision boundaries for moon-shaped data\n",
    "plot_decision_boundaries(X, y, classifiers, classifier_names)\n",
    "\n",
    "# Generate circular data\n",
    "X, y = make_circles(n_samples=200, noise=0.2, factor=0.5, random_state=42)\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k', cmap=plt.cm.RdBu)\n",
    "plt.title('Circular Data', fontsize=16)\n",
    "plt.xlabel('Feature 1', fontsize=14)\n",
    "plt.ylabel('Feature 2', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "plt.show()\n",
    "\n",
    "# Plot decision boundaries for circular data\n",
    "plot_decision_boundaries(X, y, classifiers, classifier_names)\n",
    "\n",
    "\n",
    "# ## 5. Test Your Knowledge\n",
    "\n",
    "# ### Exercise 1: Basic Plotting\n",
    "# \n",
    "# 1. Create a line plot of the function f(x) = x² - 2x + 3 for x in the range [-2, 4].\n",
    "# 2. Add a title, axis labels, and a grid.\n",
    "# 3. Add a horizontal line at y = 0 and vertical lines at x = 0 and x = 2.\n",
    "# 4. Add a text annotation pointing to the minimum of the function.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b1a1507f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "# 1. Create a line plot\n",
    "x = np.linspace(-2, 4, 100)\n",
    "y = x**2 - 2*x + 3\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(x, y, 'b-', linewidth=2, label='f(x) = x² - 2x + 3')\n",
    "\n",
    "# 2. Add title, labels, and grid\n",
    "plt.title('Quadratic Function: f(x) = x² - 2x + 3', fontsize=16)\n",
    "plt.xlabel('x', fontsize=14)\n",
    "plt.ylabel('f(x)', fontsize=14)\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "# 3. Add horizontal and vertical lines\n",
    "plt.axhline(y=0, color='k', linestyle='--', alpha=0.5)\n",
    "plt.axvline(x=0, color='k', linestyle='--', alpha=0.5)\n",
    "plt.axvline(x=2, color='r', linestyle='--', alpha=0.5, label='x = 2')\n",
    "\n",
    "# 4. Add text annotation at the minimum\n",
    "# The minimum is at x = 1 (derivative of x² - 2x + 3 = 0 gives x = 1)\n",
    "min_x = 1\n",
    "min_y = min_x**2 - 2*min_x + 3\n",
    "plt.plot(min_x, min_y, 'ro')  # Red point at minimum\n",
    "plt.annotate('Minimum: (1, 2)', xy=(min_x, min_y), xytext=(min_x+0.5, min_y+1),\n",
    "            arrowprops=dict(facecolor='black', shrink=0.05, width=1.5),\n",
    "            fontsize=12)\n",
    "\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### Exercise 2: Statistical Visualization\n",
    "# \n",
    "# 1. Generate three random datasets with different distributions (normal, uniform, and exponential).\n",
    "# 2. Create a figure with three subplots showing histograms of each distribution.\n",
    "# 3. Add kernel density estimation curves to each histogram.\n",
    "# 4. Add appropriate titles, labels, and a legend to each subplot.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ed9745ed",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "# 1. Generate three random datasets\n",
    "np.random.seed(42)\n",
    "normal_data = np.random.normal(0, 1, 1000)\n",
    "uniform_data = np.random.uniform(-2, 2, 1000)\n",
    "exponential_data = np.random.exponential(1, 1000)\n",
    "\n",
    "# 2 & 3. Create figure with histograms and KDE\n",
    "fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n",
    "\n",
    "# Normal distribution\n",
    "axes[0].hist(normal_data, bins=30, density=True, alpha=0.7, color='skyblue', label='Histogram')\n",
    "x = np.linspace(-4, 4, 1000)\n",
    "axes[0].plot(x, 1/(np.sqrt(2*np.pi)) * np.exp(-x**2/2), 'r-', linewidth=2, label='PDF')\n",
    "axes[0].set_title('Normal Distribution', fontsize=14)\n",
    "axes[0].set_xlabel('Value', fontsize=12)\n",
    "axes[0].set_ylabel('Density', fontsize=12)\n",
    "axes[0].legend()\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "# Uniform distribution\n",
    "axes[1].hist(uniform_data, bins=30, density=True, alpha=0.7, color='lightgreen', label='Histogram')\n",
    "x = np.linspace(-3, 3, 1000)\n",
    "pdf = np.zeros_like(x)\n",
    "pdf[(x >= -2) & (x <= 2)] = 0.25  # PDF of uniform(-2, 2)\n",
    "axes[1].plot(x, pdf, 'r-', linewidth=2, label='PDF')\n",
    "axes[1].set_title('Uniform Distribution', fontsize=14)\n",
    "axes[1].set_xlabel('Value', fontsize=12)\n",
    "axes[1].set_ylabel('Density', fontsize=12)\n",
    "axes[1].legend()\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "# Exponential distribution\n",
    "axes[2].hist(exponential_data, bins=30, density=True, alpha=0.7, color='salmon', label='Histogram')\n",
    "x = np.linspace(0, 8, 1000)\n",
    "axes[2].plot(x, np.exp(-x), 'r-', linewidth=2, label='PDF')\n",
    "axes[2].set_title('Exponential Distribution', fontsize=14)\n",
    "axes[2].set_xlabel('Value', fontsize=12)\n",
    "axes[2].set_ylabel('Density', fontsize=12)\n",
    "axes[2].legend()\n",
    "axes[2].grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### Exercise 3: Advanced Visualization\n",
    "# \n",
    "# 1. Create a 3D surface plot of the function f(x, y) = sin(sqrt(x² + y²)) for x and y in the range [-5, 5].\n",
    "# 2. Add a color bar to show the mapping of z-values to colors.\n",
    "# 3. Add appropriate title and axis labels.\n",
    "# 4. Create a contour plot of the same function below the 3D plot.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32501758",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "# 1. Create 3D surface plot\n",
    "x = np.linspace(-5, 5, 100)\n",
    "y = np.linspace(-5, 5, 100)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "Z = np.sin(np.sqrt(X**2 + Y**2))\n",
    "\n",
    "fig = plt.figure(figsize=(12, 10))\n",
    "\n",
    "# 3D surface plot\n",
    "ax1 = fig.add_subplot(2, 1, 1, projection='3d')\n",
    "surf = ax1.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none', alpha=0.8)\n",
    "\n",
    "# 2. Add color bar\n",
    "fig.colorbar(surf, ax=ax1, shrink=0.5, aspect=5, label='sin(sqrt(x² + y²))')\n",
    "\n",
    "# 3. Add title and labels\n",
    "ax1.set_title('3D Surface Plot: f(x, y) = sin(sqrt(x² + y²))', fontsize=16)\n",
    "ax1.set_xlabel('X', fontsize=12)\n",
    "ax1.set_ylabel('Y', fontsize=12)\n",
    "ax1.set_zlabel('Z', fontsize=12)\n",
    "\n",
    "# 4. Contour plot\n",
    "ax2 = fig.add_subplot(2, 1, 2)\n",
    "contour = ax2.contourf(X, Y, Z, 20, cmap='viridis')\n",
    "fig.colorbar(contour, ax=ax2, label='sin(sqrt(x² + y²))')\n",
    "ax2.set_title('Contour Plot: f(x, y) = sin(sqrt(x² + y²))', fontsize=16)\n",
    "ax2.set_xlabel('X', fontsize=12)\n",
    "ax2.set_ylabel('Y', fontsize=12)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ### Exercise 4: Real-world Application\n",
    "# \n",
    "# 1. Generate a synthetic dataset with two features and binary labels.\n",
    "# 2. Split the data into training and testing sets.\n",
    "# 3. Train a classifier of your choice on the training data.\n",
    "# 4. Visualize the decision boundary of the classifier.\n",
    "# 5. Add scatter plots of the training and testing data points with different markers.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e82fdb3f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Your code here\n",
    "# Example solution:\n",
    "from sklearn.datasets import make_classification\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.svm import SVC\n",
    "from sklearn.inspection import DecisionBoundaryDisplay\n",
    "\n",
    "# 1. Generate synthetic dataset\n",
    "X, y = make_classification(n_samples=200, n_features=2, n_redundant=0, \n",
    "                          n_informative=2, random_state=42, n_clusters_per_class=1)\n",
    "\n",
    "# 2. Split data into training and testing sets\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n",
    "\n",
    "# 3. Train a classifier\n",
    "clf = SVC(kernel='rbf', gamma=0.5)\n",
    "clf.fit(X_train, y_train)\n",
    "\n",
    "# 4 & 5. Visualize decision boundary and data points\n",
    "plt.figure(figsize=(10, 8))\n",
    "\n",
    "# Plot decision boundary\n",
    "DecisionBoundaryDisplay.from_estimator(\n",
    "    clf, X, cmap=plt.cm.RdBu, alpha=0.8,\n",
    "    xlabel=\"Feature 1\", ylabel=\"Feature 2\"\n",
    ")\n",
    "\n",
    "# Plot training points\n",
    "plt.scatter(X_train[:, 0], X_train[:, 1], c=y_train, edgecolors='k', \n",
    "           cmap=plt.cm.RdBu, alpha=0.6, marker='o', s=80, label='Training Data')\n",
    "\n",
    "# Plot testing points\n",
    "plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test, edgecolors='k', \n",
    "           cmap=plt.cm.RdBu, alpha=0.6, marker='^', s=80, label='Testing Data')\n",
    "\n",
    "# Add title and labels\n",
    "accuracy = clf.score(X_test, y_test)\n",
    "plt.title(f'SVM Decision Boundary (Test Accuracy: {accuracy:.2f})', fontsize=16)\n",
    "plt.xlabel('Feature 1', fontsize=14)\n",
    "plt.ylabel('Feature 2', fontsize=14)\n",
    "plt.legend()\n",
    "plt.grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "# ## 6. Additional Resources\n",
    "# \n",
    "# - [Matplotlib Documentation](https://matplotlib.org/stable/index.html)\n",
    "# - [Matplotlib Gallery](https://matplotlib.org/stable/gallery/index.html)\n",
    "# - [Python Data Science Handbook - Matplotlib Chapter](https://jakevdp.github.io/PythonDataScienceHandbook/04.00-introduction-to-matplotlib.html)\n",
    "# - [Matplotlib Cheat Sheet](https://github.com/matplotlib/cheatsheets)\n",
    "# - [Data Visualization with Matplotlib and Python](https://github.com/pb111/Data-Analysis-and-Visualization-with-Python/blob/master/Matplotlib_Basics.ipynb)\n",
    "# - [Matplotlib Tutorials](https://matplotlib.org/stable/tutorials/index.html)\n",
    "#!/usr/bin/env python\n",
    "# coding: utf-8\n",
    "\n",
